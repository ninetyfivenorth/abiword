diff -urN aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/plugin.m4 abiword-2.1.0/abiword-plugins/wp/impexp/psion/plugin.m4
--- aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/plugin.m4	2003-11-13 16:12:06.000000000 +0100
+++ abiword-2.1.0/abiword-plugins/wp/impexp/psion/plugin.m4	2004-03-17 16:23:50.856103496 +0100
@@ -17,49 +17,82 @@
 dnl= return
 dnl= ##########################################################################
 
+
 AC_DEFUN([ABIPGN_PSION],[
 
+# The required psiconv version, as reported by psiconv-config
+psiconv_major_req=0
+psiconv_minor_req=9
+psiconv_patch_req=3
+
 _abi_cppflags_save="$CPPFLAGS"
 _abi_ldflags_save="$LDFLAGS"
 
 ABI_PSION_CPPFLAGS=""
 ABI_PSION_LDFLAGS=""
+psiconvconfigdir=""
 
-# Checks for libraries.
-# Checks for header files.
-
-AC_ARG_WITH(psiconv,[  --with-psiconv=DIR      use libpsiconv in DIR],[
-	if test "x$withval" = "xno"; then
-		AC_MSG_ERROR([* * * huh? psiconv required for psion plugin! * * *])
-	elif test "x$withval" != "xyes"; then
-		CPPFLAGS="$CPPFLAGS -I$withval/include"
-		LDFLAGS="$LDFLAGS -L$withval/lib"
-	fi
+AC_ARG_WITH(psiconv-config,[  --with-psiconv-config=DIR      use psiconv-config in DIR],[
+	psiconvconfigdir="$withval"
 ])
 
-AC_CHECK_HEADER(psiconv/parse.h,[
-	AC_CHECK_LIB(psiconv,psiconv_file_type,[
-		ABI_PLUGIN_REPORT([psion: okay])
-	],[	ABI_PLUGIN_REPORT([psion: error - libpsiconv not found])
+
+if test "x$abi_plugin_disable" != "xyes"; then
+	if test "x$psiconvconfigdir" = "x"; then
+		AC_PATH_PROG(psiconvconfig,psiconv-config)
+	else
+		AC_PATH_PROG(psiconvconfig,psiconv-config,,"$psiconvconfigdir")
+	fi
+		
+	if test "x$psiconvconfig" = "x"; then
 		abi_plugin_disable=yes
-	])
-],[	ABI_PLUGIN_REPORT([psion: error - psiconv headers not found])
-	abi_plugin_disable=yes
-])
+	fi
+fi
 
-if test $abi_plugin_disable = no; then
-	if test "x$withval" != "xyes"; then
-		ABI_PSION_CPPFLAGS="-I$withval/include"
-		ABI_PSION_LDFLAGS="-L$withval/lib -lpsiconv"
+if test "x$abi_plugin_disable" != "xyes"; then
+	AC_MSG_CHECKING([for psiconv >= ${psiconv_major_req}.${psiconv_minor_req}.${psiconv_patch_req}])
+	IFS_old="$IFS"
+	IFS='.'
+	set -- `psiconv-config --version`
+	psiconv_major_found="${1}"
+	psiconv_minor_found="${2}"
+	psiconv_patch_found="${3}"
+	IFS="$IFS_old"
+	if test "$psiconv_major_found" -lt "$psiconv_major_req"; then
+		abi_plugin_disable=yes
+	elif test "$psiconv_major_found" -eq "$psiconv_major_req"; then
+		if test "$psiconv_minor_found" -lt "$psiconv_minor_req"; then
+			abi_plugin_disable=yes
+		elif test "$psiconv_minor_found" -eq "$psiconv_minor_req"; then
+			if test "$psiconv_patch_found" -lt "$psiconv_patch_req"; then
+				abi_plugin_disable=yes
+			fi
+		fi
+	fi
+	if test "x$abi_plugin_disable" = "xyes"; then
+		AC_MSG_RESULT([version ${psiconv_major_found}.${psiconv_minor_found}.${psiconv_patch_found} (Too old!)])
 	else
-		ABI_PSION_CPPFLAGS=""
-		ABI_PSION_LDFLAGS="-lpsiconv"
+		AC_MSG_RESULT([version ${psiconv_major_found}.${psiconv_minor_found}.${psiconv_patch_found} (OK)])
 	fi
 fi
 
+if test "x$abi_plugin_disable" != "xyes"; then
+	ABI_PSION_CPPFLAGS=`psiconv-config --cflags`
+	ABI_PSION_LDFLAGS=`psiconv-config --libs`
+fi
+
+ABI_PSION_CPPFLAGS="$ABI_PSION_CPPFLAGS $LIBPNG_CFLAGS"
+ABI_PSION_LDFLAGS="$ABI_PSION_LDFLAGS $LIBPNG_LDFLAGS"
+	
 AC_SUBST(ABI_PSION_CPPFLAGS)
 AC_SUBST(ABI_PSION_LDFLAGS)
 
 CPPFLAGS="$_abi_cppflags_save"
 LDFLAGS="$_abi_ldflags_save"
+
+if test "x$abi_plugin_disable" != "xyes"; then
+	ABI_PLUGIN_REPORT([psion: OK])
+else
+	ABI_PLUGIN_REPORT([psion: psiconv (>= 0.9.1) not found])
+fi
 ])
diff -urN aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/GNUmakefile.am abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/GNUmakefile.am
--- aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/GNUmakefile.am	2003-02-20 00:21:20.000000000 +0100
+++ abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/GNUmakefile.am	2004-03-17 16:20:17.862483448 +0100
@@ -6,7 +6,7 @@
 
 plugin_LTLIBRARIES = libAbiPsion.la
 
-libAbiPsion_la_SOURCES = ie_exp_Psion.cpp ie_exp_Psion.h ie_impexp_Psion.cpp ie_imp_Psion.cpp ie_imp_Psion.h
+libAbiPsion_la_SOURCES = ie_exp_Psion.cpp ie_exp_Psion.h ie_impexp_Psion.cpp ie_imp_Psion.cpp ie_imp_Psion.h ie_impexp_Psion.h
 
 libAbiPsion_la_LIBADD = @ABI_LIBS@
 
diff -urN aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_exp_Psion.cpp abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_exp_Psion.cpp
--- aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_exp_Psion.cpp	2003-05-09 17:03:06.000000000 +0200
+++ abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_exp_Psion.cpp	2004-03-17 16:20:18.613369296 +0100
@@ -1,6 +1,6 @@
 /* AbiWord
  * Copyright (C) 2000 AbiSource, Inc.
- * Copyright (C) 2000, 2001 Frodo Looijaard <frodol@dds.nl>
+ * Copyright (C) 2000, 2001, 2004 Frodo Looijaard <frodol@dds.nl>
  * 
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -37,6 +37,9 @@
 
 // Search for TODO for more things to do.
 
+
+
+
 #include "ut_string.h"
 #include "ut_bytebuf.h"
 #include "ut_units.h"
@@ -99,7 +102,7 @@
 	PD_Document *m_pDocument;
 	IE_Exp_Psion *m_pie;
 
-	UT_ByteBuf m_currentParagraphText;
+	psiconv_list m_currentParagraphText /* of psiconv_ucs2 */;
 	psiconv_paragraph_layout m_currentParagraphPLayout;
 	psiconv_character_layout m_currentParagraphCLayout;
 	bool m_inParagraph;
@@ -120,6 +123,32 @@
 /*****************************************************************/
 /*****************************************************************/
 
+static psiconv_ucs2 *utf8_to_ucs2(const XML_Char *input)
+{
+                                                                                
+    UT_uint32 read=0,written=0;
+	int i;
+    char *intermediate;
+    psiconv_ucs2 *result;
+
+    if (!input)
+        return NULL;
+    read=written=0;
+    intermediate = UT_convert((char *)input,strlen(input) * sizeof(*input),
+                      "UTF-8","UCS-2",&read,&written);
+    if (!(result = (psiconv_ucs2 *) malloc(sizeof(*result) * 
+					                       (written / 2 + 1)))) {
+		free(intermediate);
+		return NULL;
+	}
+	for (i = 0; i < written/2; i++)
+		result[i] = intermediate[i*2] + intermediate[i*2+1] << 8;
+	result[i] = 0;
+	free(intermediate);
+	return result;
+}
+
+
 IE_Exp_Psion::IE_Exp_Psion(PD_Document *pDocument)
 	: IE_Exp(pDocument)
 {
@@ -154,6 +183,7 @@
 	int iRes;
 	psiconv_file psionfile;
 	psiconv_buffer psiondump;
+	psiconv_config config;
 
 	// We allocate m_paragraphs here and not in the constructor, because
 	// we can't fail in a constructor. Note that we assume it is not
@@ -180,8 +210,15 @@
 		
 	// Translate the psiconv_file representation to a dump that can be
 	// written to file.
-	iRes = psiconv_write(&psiondump,psionfile);
+	
+	config = psiconv_config_default();
+	if (!config)
+		return UT_IE_NOMEMORY;
+	config->error_handler = &psion_error_handler;
+	psiconv_config_read(NULL,&config);
+	iRes = psiconv_write(config,&psiondump,psionfile);
 	psiconv_free_file(psionfile);
+	psiconv_config_free(config);
 	if (iRes)
 		return UT_IE_COULDNOTWRITE;
 
@@ -348,6 +385,7 @@
 	m_currentParagraphPLayout = NULL;
 	m_currentParagraphCLayout = NULL;
 	m_currentParagraphInLines = NULL;
+	m_currentParagraphText = NULL;
 }
 
 // Deallocate those psiconv_file fragments that are currently allocated.
@@ -359,6 +397,8 @@
 		psiconv_free_character_layout(m_currentParagraphCLayout);
 	if (m_currentParagraphInLines)
 		psiconv_list_free(m_currentParagraphInLines);
+	if (m_currentParagraphText)
+		psiconv_list_free(m_currentParagraphText);
 }
 
 // Standard listener callback for in-block data
@@ -380,10 +420,10 @@
 			api = pcr->getIndexAP();
 			return _addInLine(api,textlen);
 		case PX_ChangeRecord::PXT_InsertObject:
-			UT_DEBUGMSG(("Insert Object (ignored)\n"));
+			UT_DEBUGMSG(("Psion: Insert Object (ignored)\n"));
 			return true;
 		case PX_ChangeRecord::PXT_InsertFmtMark:
-			UT_DEBUGMSG(("Insert Format Mark (ignored)\n"));
+			UT_DEBUGMSG(("Psion: Insert Format Mark (ignored)\n"));
 			return true;
 		default:
 			UT_ASSERT(0);
@@ -411,7 +451,7 @@
 			break;
 		case PTX_Section:
 		case PTX_SectionHdrFtr:
-			UT_DEBUGMSG(("New section (ignored)\n"));
+			UT_DEBUGMSG(("Psion: New section (ignored)\n"));
 			if (!_closeParagraph())
 				return false;
 			return true;
@@ -468,33 +508,19 @@
 // written text in outLength; this may be more or less than inLength,
 // because some input characters may need to be represented by more than one
 // output character, and because we may ignore some input characters.
+// At this moment, we do neither, so *outlength == inLength
 bool s_Psion_Listener::_writeText(const UT_UCSChar *p, UT_uint32 inLength,
                                      UT_uint32 *outLength)
 {
-	class UT_Wctomb wctomb("CP1252");
-
-	UT_uint32 i;
-	char pC[MB_LEN_MAX];
-	int mbLen;
-
-	if (outLength)
-		*outLength = 0;
-	// I am not sure I handle the multi-byte to wide character in charset
-	// CP1252 right. Actually, I am pretty sure it is worthless :-( 
-	for (i = 0; i < inLength; i++)  {
-		if (!wctomb.wctomb(pC,mbLen,p[i])) {
-			pC[0]='?'; // Do we really want this?
-			wctomb.initialize();
-		}
-		// TODO: Check for special ASCII codes (below 32 decimal)
-		if ((mbLen ==1) && (pC[0] < 0x20)) {
-			// TODO
-		}
-		if (!m_currentParagraphText.append( (UT_Byte *) pC,mbLen))
+	int i;
+	psiconv_ucs2 character;
+	for (i = 0; i < inLength; i++) {
+		character = p[i];
+		if (psiconv_list_add(m_currentParagraphText,&character))
 			return false;
-		if (outLength)
-			*outLength += mbLen;
 	}
+	if (outLength)
+		*outLength = inLength;
 	return true;
 }
 
@@ -507,7 +533,10 @@
 	bool widowsorphans;
 
 	// New paragraph, new text.
-	m_currentParagraphText.truncate(0);
+	if (m_currentParagraphText)
+		psiconv_list_empty(m_currentParagraphText);
+	else if (!(m_currentParagraphText = psiconv_list_new(sizeof(psiconv_ucs2))))
+		return false;
 	// Set the base layout of this paragraph.
 	// TODO: This should be based on the current style!
 	if (!(m_currentParagraphPLayout = psiconv_basic_paragraph_layout()))
@@ -606,16 +635,11 @@
 bool s_Psion_Listener::_closeParagraph(void)
 {
 	struct psiconv_paragraph_s para;
+	psiconv_ucs2 *character;
 	// It is safe to call us when we are not actually in a paragraph;
 	// we will just nop.
 	if (m_inParagraph) {
-		// Append the final \000
-		if (!m_currentParagraphText.append((const UT_Byte *) "",1))
-			goto ERROR1;
-		// We need to get a copy of the paragraph text, because 
-		// m_currentParagraphText will be refilled.
-		if (!(para.text =
-	                UT_strdup((char *) m_currentParagraphText.getPointer(0))))
+		if (!(para.text = psiconv_unicode_from_list(m_currentParagraphText)))
 			goto ERROR1;
 		// Get the base paragraph and character layout.
 		para.base_character = m_currentParagraphCLayout;
@@ -658,11 +682,21 @@
 	const PP_AttrProp * pAP = NULL;
 	const XML_Char* szValue;
 	struct psiconv_in_line_layout_s curInLine;
-	char *tempstr;
+	psiconv_ucs2 *tempstr;
+	const psiconv_ucs2 text_Courier[] = {'C','o','u','r','i','e','r',0 };
+	const psiconv_ucs2 text_Mono[] = {'M','o','n','o',0 };
+	const psiconv_ucs2 text_Arial[] = {'A','r','i','a','l',0 };
+	const psiconv_ucs2 text_Goth[] = {'G','o','t','h',0 };
+	const psiconv_ucs2 text_Helvetic[] = 
+	                              {'H','e','l','v','e','t','i','c',0 };
+	const psiconv_ucs2 text_Univers[] = {'U','n','i','v','e','r','s',0 };
+	const psiconv_ucs2 text_Sans[] = {'S','a','n','s',0 };
 
 	if (!m_inParagraph)
 		return false;
 
+	curInLine.object = NULL;
+
 	curInLine.length = textlen;
 	if (!(curInLine.layout =
 	                psiconv_clone_character_layout(m_currentParagraphCLayout)))
@@ -671,22 +705,21 @@
 	if (m_pDocument->getAttrProp(api,&pAP) && pAP) {
 		if (pAP->getProperty("font-family",szValue)) {
 			tempstr = curInLine.layout->font->name;
-			if (!(curInLine.layout->font->name = 
-			                               UT_strdup((const char*) szValue))) {
+			if (!(curInLine.layout->font->name = utf8_to_ucs2(szValue))) {
 				curInLine.layout->font->name = tempstr;
 				goto ERROR;
 			}
 			free(tempstr);
 			// There may be a good general way to do this, but I do
 			// not know how.
-			if (strstr(curInLine.layout->font->name,"Courier") ||
-			    strstr(curInLine.layout->font->name,"Mono"))
+			if (psiconv_unicode_strstr(curInLine.layout->font->name,text_Courier) ||
+			    psiconv_unicode_strstr(curInLine.layout->font->name,text_Mono))
 				curInLine.layout->font->screenfont = psiconv_font_nonprop;
-			else if (strstr(curInLine.layout->font->name,"Arial") ||
-			         strstr(curInLine.layout->font->name,"Goth") ||
-			         strstr(curInLine.layout->font->name,"Helvetic") ||
-			         strstr(curInLine.layout->font->name,"Univers") ||
-			         strstr(curInLine.layout->font->name,"Sans"))
+			else if (psiconv_unicode_strstr(curInLine.layout->font->name,text_Arial) ||
+			         psiconv_unicode_strstr(curInLine.layout->font->name,text_Goth) ||
+			         psiconv_unicode_strstr(curInLine.layout->font->name,text_Helvetic) ||
+			         psiconv_unicode_strstr(curInLine.layout->font->name,text_Univers) ||
+			         psiconv_unicode_strstr(curInLine.layout->font->name,text_Sans))
 				curInLine.layout->font->screenfont = psiconv_font_sansserif;
 			else
 				curInLine.layout->font->screenfont = psiconv_font_serif;
diff -urN aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_exp_Psion.h abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_exp_Psion.h
--- aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_exp_Psion.h	2003-09-28 19:14:08.000000000 +0200
+++ abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_exp_Psion.h	2004-03-17 16:20:19.272269128 +0100
@@ -1,6 +1,6 @@
 /* AbiWord
  * Copyright (C) 2000 AbiSource, Inc.
- * Copyright (C) 2000,2001 Frodo Looijaard <frodol@dds.nl>
+ * Copyright (C) 2000,2001,2004 Frodo Looijaard <frodol@dds.nl>
  * 
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -23,6 +23,7 @@
 #define IE_EXP_PSION_H
 
 #include "ie_exp.h"
+#include "ie_impexp_Psion.h"
 #include "pl_Listener.h"
 #include "psiconv/data.h"
 
@@ -31,28 +32,6 @@
 
 // The exporter/writer for Psion Files.
 
-class ABI_PLUGIN_EXPORT IE_Exp_Psion: public IE_Exp
-{
-	// This friend declaration needs to be cleaned up, I think.
-	friend class s_Psion_Listener;
-
-public:
-	// Constructors and destructor
-	IE_Exp_Psion(PD_Document * pDocument);
-	virtual ~IE_Exp_Psion(void);
-
-protected:
-	// Overriding methods from the base class
-	virtual UT_Error _writeDocument(void);
-
-	// New methods
-	virtual psiconv_file _createPsionFile(void) = 0;
-
- protected:
-	// TODO: New data - make me private
-	s_Psion_Listener * m_pListener;
-	psiconv_text_and_layout m_paragraphs;
-};
 
 class ABI_PLUGIN_EXPORT IE_Exp_Psion_TextEd_Sniffer : public IE_ExpSniffer
 {
@@ -86,6 +65,29 @@
 										IE_Exp ** ppie);
 };
 
+class ABI_PLUGIN_EXPORT IE_Exp_Psion: public IE_Exp
+{
+	// This friend declaration needs to be cleaned up, I think.
+	friend class s_Psion_Listener;
+
+public:
+	// Constructors and destructor
+	IE_Exp_Psion(PD_Document * pDocument);
+	virtual ~IE_Exp_Psion(void);
+
+protected:
+	// Overriding methods from the base class
+	virtual UT_Error _writeDocument(void);
+
+	// New methods
+	virtual psiconv_file _createPsionFile(void) = 0;
+
+ protected:
+	// TODO: New data - make me private
+	s_Psion_Listener * m_pListener;
+	psiconv_text_and_layout m_paragraphs;
+};
+
 class ABI_PLUGIN_EXPORT IE_Exp_Psion_TextEd : public IE_Exp_Psion
 {
 public:
diff -urN aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_impexp_Psion.cpp abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_impexp_Psion.cpp
--- aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_impexp_Psion.cpp	2003-06-15 14:10:20.000000000 +0200
+++ abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_impexp_Psion.cpp	2004-03-17 16:20:19.979161664 +0100
@@ -27,7 +27,13 @@
 
 #include "ie_imp_Psion.h"
 #include "ie_exp_Psion.h"
+#include "ie_impexp_Psion.h"
 #include "xap_Module.h"
+#include "ut_debugmsg.h"
+
+#include <psiconv/data.h>
+#include <psiconv/error.h>
+#include <psiconv/unicode.h>
 
 ABI_PLUGIN_DECLARE("Psion")
 
@@ -119,3 +125,22 @@
 {
   return 1;
 }
+
+
+// The error-handler we will use when calling the psiconv library
+void psion_error_handler (int kind, psiconv_u32 off, const char *message)
+{
+	switch(kind) {
+		case PSICONV_VERB_FATAL:
+		case PSICONV_VERB_ERROR:
+			UT_WARNINGMSG(("%s\n",message));
+			break;
+                                                                                
+		//case PSICONV_VERB_DEBUG:
+		//case PSICONV_VERB_WARN:
+		//case PSICONV_VERB_PROGRESS:
+		default:
+			UT_DEBUGMSG(("PSION: %s\n",message));
+	}
+}
+
diff -urN aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_impexp_Psion.h abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_impexp_Psion.h
--- aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_impexp_Psion.h	1970-01-01 01:00:00.000000000 +0100
+++ abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_impexp_Psion.h	2004-03-17 16:20:19.979161664 +0100
@@ -0,0 +1,31 @@
+/* AbiWord
+ * Copyright (C) 2000 AbiSource, Inc.
+ * Copyright (C) 2000,2004 Frodo Looijaard <frodol@dds.nl>
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
+ * 02111-1307, USA.
+ */
+
+/* This importer/exporter was written by Frodo Looijaard <frodol@dds.nl> */
+
+#ifndef IE_IMPEXP_PSION_H
+#define IE_IMPEXP_PSION_H
+
+#include <psiconv/data.h>
+
+extern void psion_error_handler (int kind, psiconv_u32 off, 
+                                 const char *message);
+
+#endif /* IE_IMPEXP_PSION_H */
diff -urN aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_imp_Psion.cpp abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_imp_Psion.cpp
--- aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_imp_Psion.cpp	2003-10-27 18:10:18.000000000 +0100
+++ abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_imp_Psion.cpp	2004-03-17 16:20:20.677055568 +0100
@@ -1,6 +1,6 @@
 /* AbiWord
  * Copyright (C) 2000 AbiSource, Inc.
- * Copyright (C) 2000 Frodo Looijaard <frodol@dds.nl>
+ * Copyright (C) 2000,2004 Frodo Looijaard <frodol@dds.nl>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -24,30 +24,21 @@
 //  We use libpsiconv for the real work
 
 // To do once Abiword supports it:
-//   Styles: enable
 //   Page header and footer, page size, first page number
-//   Paragraph borders and background color
+//   Paragraph border
 
-// Note that the current bullets implementation is incompatible with
-// styles: for a bullet to be displayed, we *have to set the paragraph
-// style to `Bullet List'. The current bullet implementation is one big
-// nasty hack :-(
 #include <stdio.h>
 
 #include "ut_types.h"
 #include "ut_assert.h"
 #include "ut_debugmsg.h"
 #include "ut_string.h"
-#include "ut_growbuf.h"
-#include "ut_mbtowc.h"
 #include "ut_units.h"
-#include "ut_bytebuf.h"
+#include "ut_string_class.h"
 
 #include "pd_Document.h"
 #include "xap_EncodingManager.h"
 
-#include "ut_string_class.h"
-
 #include "ie_impGraphic.h"
 #include "fg_Graphic.h"
 #include "fg_GraphicRaster.h"
@@ -56,42 +47,140 @@
 #include "ie_imp_Psion.h"
 #include <psiconv/parse.h>
 
-/*****************************************************************/
-/*****************************************************************/
 
-IE_Imp_Psion_Word_Sniffer::IE_Imp_Psion_Word_Sniffer (const char * name) :
-  IE_ImpSniffer(name)
+/***********************
+ * Auxiliary functions *
+ ***********************/
+
+static const XML_Char *global_listid = "1000";
+
+/*!
+ * Translate the stylename in UCS2 to a sanitized UTF8 string.
+ * 
+ * The input is a psiconv UCS2 string; the output an Abiword UTF8 string.
+ * Special characters are filtered away.
+ * \return NULL if input is NULL or something went horribly wrong, the
+ * UTF8 string otherwise.
+ */
+static XML_Char *prepare_style_name(const psiconv_string_t input)
 {
-  // 
+	psiconv_string_t input_copy;
+	XML_Char *result;
+	UT_uint32 i,read,written;
+	
+	if (!(input_copy = psiconv_unicode_strdup(input)))
+		return NULL;
+	for (i = 0; i < psiconv_unicode_strlen(input_copy);i++) 
+		if ((input[i] < 0x20) || (input[i] == ';') || (input[i] == ':')) 
+			input[i] = '?';
+	read=written=0;
+	result = UT_convert((char *)input,
+					    psiconv_unicode_strlen(input) * sizeof(*input),
+					    "UCS-2","UTF-8",&read,&written);
+	free(input_copy);
+	return result;
 }
 
-UT_Confidence_t IE_Imp_Psion_Word_Sniffer::recognizeContents(const char * szBuf,
-												  UT_uint32 iNumbytes)
+/*! Write data to the PNG stream
+ *
+ * This is a callback function for the PNG library. It is called when 
+ * some data needs to writting to the PNG file. We have implemented it as
+ * writing to a ByteBuf.
+ */
+static void write_png_data(png_structp png_ptr, png_bytep data, 
+                           png_size_t length) 
 {
+	UT_ByteBuf* bb = (UT_ByteBuf*) (png_get_io_ptr(png_ptr));
+    UT_DEBUGMSG(("PSION: write_png_data: %d bytes\n",length));
+	bb->append(data,length);
+}
+
+/*! Flush the PNG stream 
+ *
+ * This is a callback function for the PNG library. It is called when
+ * writing of the PNG file is finished.
+ * Nothing needs to be done.
+ */
+static void write_png_flush(png_structp png_ptr)
+{
+}
+
+
+/******************************
+ * class IE_Imp_Psion_Sniffer *
+ ******************************/
 
+/*!
+ * Check whether this is a Psion file of the given type
+ *
+ * This is used by the recognizeContents methods of the Word and TextEd
+ * sniffers.
+ * \return Psion files have strong magic, so we either return 
+ * UT_CONFIDENCE_PERFECT or UT_CONFIDENCE_ZILCH.
+ */
+UT_Confidence_t IE_Imp_Psion_Sniffer::checkContents(const char * szBuf,
+												UT_uint32 iNumbytes,
+												psiconv_file_type_t filetype)
+{
 	UT_uint32 i;
+	psiconv_config config;
+	psiconv_buffer pl;
+	psiconv_file_type_t filetype_detected;
+
+	// Prepare a new psiconv_config object
+	config = psiconv_config_default();
+	if (!config)
+		goto ERROR1;
+	config->error_handler = &psion_error_handler;
+	psiconv_config_read(NULL,&config);
+	// It is likely detection will fail, so keep it silent.
+	config->verbosity = PSICONV_VERB_FATAL;
 
-	psiconv_buffer pl = psiconv_buffer_new();
+	// Copy the file data into a psiconv_buffer.
+	pl = psiconv_buffer_new();
 	if (!pl)
-		return UT_CONFIDENCE_ZILCH;
+		goto ERROR2;
 	for (i=0; i < iNumbytes; i++)
 		if ((psiconv_buffer_add(pl,szBuf[i]))) {
-			psiconv_buffer_free(pl);
-			return UT_CONFIDENCE_ZILCH;
+				goto ERROR3;
 		}
 
-	// It is likely detection will fail, so keep it silent
-	int verbosity=psiconv_verbosity;
-	psiconv_verbosity=PSICONV_VERB_FATAL;
-	psiconv_file_type_t filetype = psiconv_file_type(pl,NULL,NULL);
-	psiconv_verbosity = verbosity;
+	// Check whether this is a Psion file.
+	filetype_detected = psiconv_file_type(config,pl,NULL,NULL);
 	psiconv_buffer_free(pl);
-	if (filetype == psiconv_word_file)
+	psiconv_config_free(config);
+	if (filetype == filetype_detected)
 		return UT_CONFIDENCE_PERFECT;
 	else
 		return UT_CONFIDENCE_ZILCH;
+
+ERROR3:
+	psiconv_buffer_free(pl);
+ERROR2:
+	psiconv_config_free(config);
+ERROR1:
+	return UT_CONFIDENCE_ZILCH;
+}
+
+
+/***********************************
+ * class IE_Imp_Psion_Word_Sniffer *
+ ***********************************/
+
+/*!
+ * Check whether this is a Psion Word file
+ */
+UT_Confidence_t IE_Imp_Psion_Word_Sniffer::recognizeContents(const char * szBuf,
+												  UT_uint32 iNumbytes)
+{
+	return checkContents(szBuf,iNumbytes,psiconv_word_file);
 }
 
+/*!
+ * Look at the extension to guess whether this is a Psion Word file.
+ * Actually, the Psion itself does not use extensions (much), so I just
+ * made up my own convention (.psiword) here. It's better than nothing.
+ */
 UT_Confidence_t IE_Imp_Psion_Word_Sniffer::recognizeSuffix(const char * szSuffix)
 {
 	if (UT_stricmp(szSuffix,".psiword") == 0)
@@ -99,6 +188,9 @@
 	return UT_CONFIDENCE_ZILCH;
 }
 
+/*!
+ * Construct a new IE_Imp object with a IE_Imp_Psion_Word_Sniffer sniffer
+ */
 UT_Error IE_Imp_Psion_Word_Sniffer::constructImporter(PD_Document * pDocument,
 													  IE_Imp ** ppie)
 {
@@ -107,7 +199,9 @@
 	return UT_OK;
 }
 
-// We take the .psiword suffix for now (no standard)
+/*!
+ * Some import filter settings. We use the .psiword extension
+ */
 bool	IE_Imp_Psion_Word_Sniffer::getDlgLabels(const char ** pszDesc,
 												const char ** pszSuffixList,
 												IEFileType * ft)
@@ -118,41 +212,26 @@
 	return true;
 }
 
-/*****************************************************************/
-/*****************************************************************/
 
-IE_Imp_Psion_TextEd_Sniffer::IE_Imp_Psion_TextEd_Sniffer (const char * name) :
-  IE_ImpSniffer(name)
-{
-  // 
-}
+/*************************************
+ * class IE_Imp_Psion_TextEd_Sniffer *
+ *************************************/
+
 
+/*!
+ * Check whether this is a Psion TextEd file
+ */
 UT_Confidence_t IE_Imp_Psion_TextEd_Sniffer::recognizeContents(const char * szBuf,
 													UT_uint32 iNumbytes)
 {
-
-	UT_uint32 i;
-
-	psiconv_buffer pl = psiconv_buffer_new();
-	if (!pl)
-		return UT_CONFIDENCE_ZILCH;
-	for (i=0; i < iNumbytes; i++)
-		if ((psiconv_buffer_add(pl,szBuf[i]))) {
-			psiconv_buffer_free(pl);
-			return UT_CONFIDENCE_ZILCH;
-		}
-	// Keep it silent...
-	int verbosity=psiconv_verbosity;
-	psiconv_verbosity=PSICONV_VERB_FATAL;
-	psiconv_file_type_t filetype = psiconv_file_type(pl,NULL,NULL);
-	psiconv_verbosity = verbosity;
-	psiconv_buffer_free(pl);
-	if (filetype == psiconv_texted_file)
-		return UT_CONFIDENCE_PERFECT;
-	else
-		return UT_CONFIDENCE_ZILCH;
+	return checkContents(szBuf,iNumbytes,psiconv_texted_file);
 }
 
+/*!
+ * Look at the extension to guess whether this is a Psion TextEd file.
+ * Actually, the Psion itself does not use extensions (much), so I just
+ * made up my own convention (.psitext) here. It's better than nothing.
+ */
 UT_Confidence_t IE_Imp_Psion_TextEd_Sniffer::recognizeSuffix(const char * szSuffix)
 {
 	if (UT_stricmp(szSuffix,".psitext") == 0)
@@ -160,14 +239,20 @@
 	return UT_CONFIDENCE_ZILCH;
 }
 
-UT_Error IE_Imp_Psion_TextEd_Sniffer::constructImporter(PD_Document * pDocument, IE_Imp ** ppie)
+/*!
+ * Construct a new IE_Imp object with a IE_Imp_Psion_TextEd_Sniffer sniffer
+ */
+UT_Error IE_Imp_Psion_TextEd_Sniffer::constructImporter(PD_Document * pDocument,
+                                                        IE_Imp ** ppie)
 {
 	IE_Imp_Psion_TextEd * p = new IE_Imp_Psion_TextEd(pDocument);
 	*ppie = p;
 	return UT_OK;
 }
 
-// We take the .psi suffix for now, but this will need to change to none at all
+/*!
+ * Some import filter settings. We use the .psitext extension
+ */
 bool IE_Imp_Psion_TextEd_Sniffer::getDlgLabels(const char ** pszDesc,
 											   const char ** pszSuffixList,
 											   IEFileType * ft)
@@ -178,38 +263,53 @@
 	return true;
 }
 
-/*****************************************************************/
-/*****************************************************************/
 
+/**********************
+ * class IE_Imp_Psion *
+ **********************/
+
+/*!
+ * Import a file with the given filename from disk.
+ */
 UT_Error IE_Imp_Psion::importFile(const char * szFilename)
 {
-	FILE *fp = fopen(szFilename, "rb");
-	psiconv_buffer buf;
-	psiconv_file psionfile;
 	int res;
+	psiconv_file psionfile;
+	UT_Error err = UT_IE_NOMEMORY;
+	FILE *fp;
+	psiconv_buffer buf;
+	psiconv_config config;
 
-	if (!fp)
-	{
-		UT_DEBUGMSG(("Could not open file %s\n",szFilename));
-		return UT_errnoToUTError ();
-	}
+	// Open the file for reading
+	fp = fopen(szFilename,"rb");
+	if (!fp) {
+		UT_DEBUGMSG(("PSION: Could not open file %s\n",szFilename));
+		err = UT_errnoToUTError ();
+		goto ERROR1;
+	}
+
+	// Read the file contents into a new psiconv_buffer
+	if (!(buf = psiconv_buffer_new())) 
+		goto ERROR2;
+	if (psiconv_buffer_fread_all(buf,fp))
+		goto ERROR3;
+
+	// Prepare a new psiconv_config object
+	config = psiconv_config_default();
+	if (!config)
+		goto ERROR3;
+	config->error_handler = psion_error_handler;
+	psiconv_config_read(NULL,&config);
 
-	if (!(buf = psiconv_buffer_new())) {
-		fclose(fp);
-		return(UT_IE_NOMEMORY);
-	}
-
-	if (psiconv_buffer_fread_all(buf,fp)) {
-		psiconv_buffer_free(buf);
-		fclose(fp);
-		return UT_IE_NOMEMORY;
-	}
+	// Try to parse the file contents into psiconv internal data structures
+	res = psiconv_parse(config,buf,&psionfile);
 
+	// Tidy up
 	fclose(fp);
-
-	res = psiconv_parse(buf,&psionfile);
+	psiconv_config_free(config);
 	psiconv_buffer_free(buf);
 
+	// Check whether this was a parsable Psion document
 	if (res) {
 		if (res == PSICONV_E_NOMEM)
 			return UT_IE_NOMEMORY;
@@ -217,96 +317,68 @@
 			return UT_IE_BOGUSDOCUMENT;
 	}
 
+	// Translate the file into an AbiWord document
 	return parseFile(psionfile);
-}
-
-/*****************************************************************/
-/*****************************************************************/
 
-// Callback function to emit psiconv error and debug messages.
-static void psion_error_handler (int kind, psiconv_u32 off, const char *message)
-{
-	switch(kind)
-	{
-		case PSICONV_VERB_FATAL:
-			UT_WARNINGMSG(("%s\n",message));
-		break;
-
-		//case PSICONV_VERB_DEBUG:
-		//case PSICONV_VERB_WARN:
-		//case PSICONV_VERB_PROGRESS:
-		default:
-			// We need to output messages even if not in debug mode...
-			_UT_OutputMessage("%s\n",message);
-	}
-}
-
-// Destructor. Note that we do not reset the psiconv error handler or the
-// verbosity: they are global for the whole program. Fortunately, we do
-// not want to change them.
-IE_Imp_Psion::~IE_Imp_Psion()
-{
-}
-
-// Constructor. We set the psiconv verbosity and error handlers here;
-// strictly taken, this needs only to be done once in the whole program,
-// but this is so much easier.
-IE_Imp_Psion::IE_Imp_Psion(PD_Document * pDocument)
-	: IE_Imp(pDocument)
-{
-	// Ouch. This is ugly. We simply never reset it.
-	psiconv_error_handler = (psiconv_error_handler_t)&psion_error_handler;
-#ifdef UT_DEBUG
-	psiconv_verbosity=PSICONV_VERB_DEBUG;
-#else
-	psiconv_verbosity=PSICONV_VERB_WARN;
-#endif
-	listid = NULL;
+ERROR3:
+	psiconv_buffer_free(buf);
+ERROR2:
+	fclose(fp);
+ERROR1:
+	return err;
 }
 
-/*****************************************************************/
-/*****************************************************************/
 
-// Output all styles.
-bool IE_Imp_Psion::applyStyles(psiconv_word_styles_section style_sec)
+/*!  
+ * Append all styles from the Psion Word Styles Section.
+ */
+UT_Error IE_Imp_Psion::applyStyles(const psiconv_word_styles_section style_sec)
 {
-	// UT_Byte is `unsigned char', so we need some nasty casts :-(
-	class UT_ByteBuf props(256);
+	UT_UTF8String props;
 
 	int i;
-	const XML_Char *stylename;
+	XML_Char *stylename;
 	psiconv_word_style style;
+	UT_Error res;
 
+	// Iterate through all defined styles.
+	// Index -1 is misused to represent the default "Normal" style.
 	for (i = -1; i < (int) psiconv_list_length(style_sec->styles); i++) {
+
 		if (i == -1)
 			style = style_sec->normal;
 		else if (!(style = (psiconv_word_style)
 		                    psiconv_list_get(style_sec->styles,i)))
-			return false;
-		// UT_DEBUGMSG(("Importing style %s\n",style->name));
-		props.truncate(0);
-		if (!getParagraphAttributes(style->paragraph,&props))
-			return false;
-		if (!getCharacterAttributes(style->character,&props))
-			return false;
+			return UT_IE_IMPORTERROR;
+		
+		// Get the style paragraph and character attributes.
+		props.clear();
+		if ((res = getParagraphAttributes(style->paragraph,props)))
+			return res;
+
+		if ((res = getCharacterAttributes(style->character,props)))
+			return res;
+
 		// Not yet implemented: hotkey
 		// Not yet implemented: built_in
 		// Not yet implemented: outline_level
+		// The three unimplemented features above are not yet available
+		// within AbiWord.
 
-		// Append the string termination character '\000'
-		if (!(props.append((unsigned char *) "",1)))
-			return false;
-
+		// Get the style name.
 		if (i == -1)
-			stylename = (const XML_Char *) "Normal";
-		else
-			stylename = (const XML_Char *) style->name;
+			stylename = (XML_Char *) strdup("Normal");
+		else 
+			stylename = prepare_style_name(style->name);
+		if (!stylename)
+			return UT_IE_NOMEMORY;
 
-		// UT_DEBUGMSG(("Style attributes: %s\n",props.getPointer(0)));
+		UT_DEBUGMSG(("PSION: Importing style %s\n",stylename));
+		UT_DEBUGMSG(("PSION: Style attributes: %s\n",props.utf8_str()));
 
 		const XML_Char* propsArray[7];
 		propsArray[0] = (const XML_Char *) "props";
-		propsArray[1] = (const XML_Char *) props.getPointer(0);
+		propsArray[1] = (const XML_Char *) props.utf8_str();
 		propsArray[2] = (const XML_Char *) "name";
 		propsArray[3] = stylename;
 		// All Psion styles are based upon the Normal style
@@ -314,251 +386,320 @@
 		propsArray[5] = (const XML_Char *) "Normal";
 		propsArray[6] = (const XML_Char *) NULL;
 
-		if (!( getDoc()->appendStyle(propsArray))) {
-			UT_DEBUGMSG(("AppendStyle failed...\n"));
-			return false;
+		if (!(getDoc()->appendStyle(propsArray))) {
+			UT_DEBUGMSG(("PSION: AppendStyle failed...\n"));
+			free(stylename);
+			return UT_IE_IMPORTERROR;
 		}
+		free(stylename);
 	}
-	return true;
+	return UT_OK;
 }
 
-// Set all page (section) attributes, and do an appendStrux(PTX_Section,...)
-// These settings are global for the whole document: Psion documents
-// contain only one single section.
-bool IE_Imp_Psion::applyPageAttributes(psiconv_page_layout_section layout)
+/*! 
+ * Add the page attributes to the documents
+ *
+ * Set all page (section) attributes, and do an appendStrux(PTX_Section,...)
+ * These settings are global for the whole document: Psion documents
+ * contain only one single section.
+ */
+UT_Error IE_Imp_Psion::applyPageAttributes(const psiconv_page_layout_section layout,
+                                           bool &with_header, bool &with_footer)
 {
 	UT_return_val_if_fail(layout != NULL, true /* perhaps should be false, but we want loading to proceed */);
 
-	// UT_Byte is `unsigned char', so we need some nasty casts :-(
-	class UT_ByteBuf props(256);
-	// This is only used for fixed string expansions, and should be big
-	// enough in all circumstances.
-	UT_String buffer;
-
-	// first page number: not yet implemented
+	UT_UTF8String props,buffer;
+	const XML_Char* propsArray[11];
+	UT_Error res;
+	int i;
 
+	// Determine whether we have a header and a footer. We can't append them
+	// here, because they have to come after the main section (or AbiWord will
+	// become very confused).
+	with_header = layout->header && layout->header->text && 
+		          layout->header->text->paragraphs &&
+		          psiconv_list_length(layout->header->text->paragraphs);
+	with_footer = layout->footer && layout->footer->text && 
+		          layout->footer->text->paragraphs &&
+		          psiconv_list_length(layout->footer->text->paragraphs);
+	
+	// Page width
+	propsArray[0] = (const XML_Char *) "width";
+	UT_UTF8String_sprintf(buffer,"%6.3f",layout->page_width);
+	propsArray[1] = (const XML_Char *) (buffer.utf8_str());
+	
+	// Page height
+	propsArray[2] = (const XML_Char *) "height";
+	UT_UTF8String_sprintf(buffer,"%6.3f",layout->page_width);
+	propsArray[3] = (const XML_Char *) (buffer.utf8_str());
+	
+	// Units of width/height
+	propsArray[4] = (const XML_Char *) "units";
+	propsArray[5] = (const XML_Char *) "cm";
+	
+	// Orientation
+	propsArray[6] = (const XML_Char *) "orientation";
+	propsArray[7] = (const XML_Char *) (layout->landscape?"landscape":"portrait");
+	
+	// Page type (we should check for common ones here!)
+	propsArray[8] = (const XML_Char *) "pagetype";
+	propsArray[9] = (const XML_Char *) "Custom";
+	
+	propsArray[10] = NULL;
+	
+	if (!(getDoc()->setPageSizeFromFile(propsArray)))
+		return UT_IE_IMPORTERROR;
+
+	// First page number not yet implemented
+	// On first page not yet implemented
+	
 	// left margin
-	UT_String_sprintf(buffer,"page-margin-left:%6.3fcm",layout->left_margin);
-	if (!(props.append((unsigned char *) buffer.c_str(),buffer.size())))
-		return false;
+	UT_UTF8String_sprintf(buffer,"page-margin-left:%6.3fcm",layout->left_margin);
+	props += buffer;
 
 	// right margin
-	UT_String_sprintf(buffer,"; page-margin-right:%6.3fcm",layout->right_margin);
-	if (!(props.append((unsigned char *) buffer.c_str(),buffer.size())))
-		return false;
+	UT_UTF8String_sprintf(buffer,"; page-margin-right:%6.3fcm",layout->right_margin);
+	props += buffer;
 
 	// top margin
-	UT_String_sprintf(buffer,"; page-margin-top:%6.3fcm",layout->top_margin);
-	if (!(props.append((unsigned char *) buffer.c_str(),buffer.size())))
-		return false;
+	UT_UTF8String_sprintf(buffer,"; page-margin-top:%6.3fcm",layout->top_margin);
+	props += buffer;
 
 	// bottom margin
-	UT_String_sprintf(buffer,"; page-margin-bottom:%6.3fcm",layout->bottom_margin);
-	if (!(props.append((unsigned char *) buffer.c_str(),buffer.size())))
-		return false;
-
-	getDoc()->m_docPageSize.Set (layout->page_width, layout->page_height,
-				     DIM_CM);
-
+	UT_UTF8String_sprintf(buffer,"; page-margin-bottom:%6.3fcm",layout->bottom_margin);
+	props += buffer;
+	
+	// header distance
+	UT_UTF8String_sprintf(buffer,"; page-margin-header:%6.3fcm",layout->header_dist);
+	props += buffer;
+	
+	// footer distance
+	UT_UTF8String_sprintf(buffer,"; page-margin-footer:%6.3fcm",layout->footer_dist);
+	props += buffer;
+	
+	
 	// Header and footer: not yet implemented (complex!)
 
-	// Append the string termination character '\000'
-	if (!(props.append((unsigned char *) "",1)))
-		return false;
-
-	// UT_DEBUGMSG(("Page: %s\n",props.getPointer(0)));
-	const XML_Char* propsArray[3];
+	// Now actually append the properties in a PTX_Section strux to the document
+	UT_DEBUGMSG(("PSION: Page: %s\n",props.utf8_str()));
 	propsArray[0] = (const XML_Char *) "props";
-	propsArray[1] = (const XML_Char *) props.getPointer(0);
-	propsArray[2] = (const XML_Char *) NULL;
-
-	return  appendStrux(PTX_Section,propsArray);
+	propsArray[1] = (const XML_Char *) props.utf8_str();
+	i = 2;
+	if (with_header) {
+		propsArray[i++] = (const XML_Char *) "header";
+		propsArray[i++] = (const XML_Char *) "1";
+	}
+	if (with_footer) {
+		propsArray[i++] = (const XML_Char *) "footer";
+		propsArray[i++] = (const XML_Char *) "2";
+	}
+	propsArray[i] = (const XML_Char *) NULL;
+	if (!(appendStrux(PTX_Section,propsArray)))
+		return UT_IE_IMPORTERROR;
+	return UT_OK;
 }
 
+UT_Error IE_Imp_Psion::processHeaderFooter(const psiconv_page_layout_section layout,
+                                           bool with_header, bool with_footer)
+{
+	const XML_Char* propsArray[5];
+	UT_Error res;
+	
+	// Header
+	if (with_header) {
+		propsArray[0] = (const XML_Char *) "id";
+		propsArray[1] = (const XML_Char *) "1";
+		propsArray[2] = (const XML_Char *) "type";
+		propsArray[3] = (const XML_Char *) "header";
+		propsArray[4] = NULL;
+		if (!appendStrux(PTX_SectionHdrFtr,propsArray))
+			return UT_IE_IMPORTERROR;
+		if ((res = readParagraphs(layout->header->text->paragraphs,NULL)))
+			return res;
+	}
+	
+	// Footer
+	if (with_footer) {
+		propsArray[0] = (const XML_Char *) "id";
+		propsArray[1] = (const XML_Char *) "2";
+		propsArray[2] = (const XML_Char *) "type";
+		propsArray[3] = (const XML_Char *) "footer";
+		propsArray[4] = NULL;
+		if (!appendStrux(PTX_SectionHdrFtr,propsArray))
+			return UT_IE_IMPORTERROR;
+		if ((res = readParagraphs(layout->footer->text->paragraphs,NULL)))
+			return res;
+	}
+}
 
-// Get all paragraph-related attributes and append them to props.
-// Note that you have to append a string termination character yourself!
-// props is allocated on the heap if it is NULL.
-// If props is not empty, we start with '; ', else we do not.
-bool IE_Imp_Psion::getParagraphAttributes(psiconv_paragraph_layout layout,
-                                             UT_ByteBuf *props)
+/*!  
+ * Get all paragraph-related attributes and append them to props.
+ *
+ * If props is not empty, we start with '; ', else we do not.
+ */
+UT_Error IE_Imp_Psion::getParagraphAttributes(const psiconv_paragraph_layout layout,
+                                          UT_UTF8String &props)
 {
 	UT_return_val_if_fail(layout != NULL, true /* perhaps should be false, but we want loading to proceed */);
 
-	// This is only used for fixed string expansions, and should be big
-	// enough in all circumstances.
-	UT_String buffer;
+	UT_UTF8String buffer;
+	psiconv_length_t indent_left,indent_first;
 
 	int i;
 	psiconv_tab tab;
-	bool props_allocated = false;
-
-	if (!props) {
-		props = new UT_ByteBuf(256);
-		props_allocated = true;
-	}
-
-	// If this is a bulleted paragraph with indent, we need to make sure
-	// the indent_first is positive. Stupid Psion.
+	
+	// Compute the indent_left and indent_first settings. Note that 
+	// indent_first is always relative to indent_left. There are a few
+	// special cases related to bullets; see the psiconv docs for details.
 	if (layout->bullet && layout->bullet->on && layout->bullet->indent &&
-	    (layout->indent_first > 0)) {
-		layout->indent_left += layout->indent_first;
-		layout->indent_first = -layout->indent_first;
-	}
-
-	if (props->getLength())
-		if (!(props->append((unsigned char *) "; ",2)))
-			goto ERROR;
+		(layout->indent_first > 0)) 
+		indent_left = layout->indent_left + layout->indent_first;
+	else
+		indent_left = layout->indent_left;
+	if (layout->bullet && layout->bullet->on && (layout->indent_first > 0))
+		if (layout->bullet->indent)
+			indent_first = -layout->indent_first;
+		else
+			indent_first = 0;
+	else
+		indent_first = layout->indent_first;
+	
+	// Append a semicolon if there is already text in the props
+	if (props.length())
+		props += ";";
 
 	// Left indent
-	UT_String_sprintf(buffer,"margin-left:%6.3fcm",layout->indent_left);
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
+	UT_UTF8String_sprintf(buffer,"margin-left:%6.3fcm",indent_left);
+	props += buffer;
 
 	// Right indent
-	UT_String_sprintf(buffer,"; margin-right:%6.3fcm",layout->indent_right);
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
+	UT_UTF8String_sprintf(buffer,"; margin-right:%6.3fcm",layout->indent_right);
+	props += buffer;
 
 	// First line indent
-	UT_String_sprintf(buffer,"; text-indent:%6.3fcm",layout->indent_first);
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	UT_UTF8String_sprintf(buffer,"; text-indent:%6.3fcm",indent_first);
+	props += buffer;
+	
 	// Horizontal justify
-	UT_String_sprintf(buffer,"; text-align:%s",
+	UT_UTF8String_sprintf(buffer,"; text-align:%s",
 	                   layout->justify_hor==psiconv_justify_left  ? "left" :
 	                   layout->justify_hor==psiconv_justify_right ? "right":
 	                   layout->justify_hor==psiconv_justify_centre? "center":
 	                                                                "justify");
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	props += buffer;
+	
 	// Vertical justify: ignored (never used in Word documents)
 
-	// background color: not yet implemented; what would its name be?!?
-	UT_String_sprintf(buffer, "; bgcolor: %02x%02x%02x",
+	// Background color
+	UT_UTF8String_sprintf(buffer, "; bgcolor: %02x%02x%02x",
 			  layout->back_color->red,
 			  layout->back_color->green,
 			  layout->back_color->blue);
-	props->append((unsigned char *) buffer.c_str(),buffer.size());
+	props += buffer;
 
 	// Linespacing
-	UT_String_sprintf(buffer, "; line-height: %dpt",(int) layout->linespacing);
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
+	UT_UTF8String_sprintf(buffer, "; line-height: %dpt",(int) layout->linespacing);
+	props += buffer;	
 	if (! layout->linespacing_exact)
-		if (!(props->append((unsigned char *) "+",1)))
-			goto ERROR;
-
+		props += "+";
+		
 	// Space above
-	UT_String_sprintf(buffer,"; margin-top:%dpt",(int) layout->space_above);
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	UT_UTF8String_sprintf(buffer,"; margin-top:%dpt",(int) layout->space_above);
+	props += buffer;
+	
 	// Space below
-	UT_String_sprintf(buffer,"; margin-bottom:%dpt",(int) layout->space_below);
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	UT_UTF8String_sprintf(buffer,"; margin-bottom:%dpt",(int) layout->space_below);
+	props += buffer;
+	
 	// Keep together
-	UT_String_sprintf(buffer,"; keep-together:%s",layout->keep_together?"yes":"no");
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	UT_UTF8String_sprintf(buffer,"; keep-together:%s",layout->keep_together?"yes":"no");
+	props += buffer;
+	
 	// Keep with next
-	UT_String_sprintf(buffer,"; keep-with-next:%s",layout->keep_with_next?"yes":"no");
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	UT_UTF8String_sprintf(buffer,"; keep-with-next:%s",layout->keep_with_next?"yes":"no");
+	props += buffer;
+	
 	// On next page
 	// This is not yet implemented in AbiWord. We use a hack in
 	// applyParagraphAttributes; styles are out of luck in this.
-
+	// Last checked 20040229: Dialog is available, but no property yet.
+	
 	// Widow control
 	// I'm not quite sure about the difference between setting widows and
 	// orphans?!?
-
-	UT_String_sprintf(buffer,"; widows:%d; orphans:%d",
+	UT_UTF8String_sprintf(buffer,"; widows:%d; orphans:%d",
 	        layout->no_widow_protection?0:2,
 	        layout->no_widow_protection?0:2);
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	props += buffer;
+	
 	// Default tab interval.
-	UT_String_sprintf(buffer,"; default-tab-interval:%6.3fcm",layout->tabs->normal);
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	UT_UTF8String_sprintf(buffer,"; default-tab-interval:%6.3fcm",layout->tabs->normal);
+	props += buffer;
+	
 	// Other tabs
 	if (psiconv_list_length(layout->tabs->extras)) {
-		buffer += "; tabstops:";
-		if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-			goto ERROR;
+		props += "; tabstops:";
 		for (i = 0; i < (int) psiconv_list_length(layout->tabs->extras); i++) {
 			if (!(tab = (psiconv_tab) psiconv_list_get(layout->tabs->extras,
 			                                           i))) {
 				UT_ASSERT(tab != NULL);
-				return(false);
+				return(UT_IE_IMPORTERROR);
 			}
-			UT_String_sprintf(buffer, "%s%6.3fcm/%c",
+			UT_UTF8String_sprintf(buffer, "%s%6.3fcm/%c",
 					i==0?"":",",
 					tab->location,
 					tab->kind == psiconv_tab_centre?'C':
 			        tab->kind == psiconv_tab_right? 'R':
 			                                        'L');
-			if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-				goto ERROR;
+			props += buffer;
 		}
 	}
 
 	// Bullets. I don't think there is a general way to do this yet.
-	// For now, we will hardcode all bullets to style 'Bullet List',
+	// For now, we will hardcode all bullets to type 'Bullet List',
 	// because we might get into real trouble. Note that we hack
-	// this together in applyParagraphAttributes. That means we can
-	// not combine styles with bullets, and do other nifty things.
-
+	// this together in applyParagraphAttributes.
+	
 	// Not yet implemented: borders
+	// These are not yet available in AbiWord.
 
-	return true;
-
-ERROR:
-	if (props_allocated)
-		delete props;
-	return  false;
+	return UT_OK;
 }
 
-// Amazing. This actually works, even though it is stolen from the RTF importer
-// and mutilated severely by me.
-// It does an appendStrux setting the current paragraph attributes and opening
-// a new paragraph.
-bool IE_Imp_Psion::applyParagraphAttributes(psiconv_paragraph_layout layout,
-                      const char *stylename)
+/*!  
+ * Get all paragraph-related attributes and add them to the document.
+ *
+ * It does an appendStrux setting the current paragraph attributes and opening
+ * a new paragraph. Several special cases are handled here too, mostly for
+ * bullets.
+ */
+UT_Error IE_Imp_Psion::applyParagraphAttributes(const psiconv_paragraph_layout layout,
+                      const XML_Char *stylename)
 {
 	UT_return_val_if_fail(layout != NULL, true /* perhaps should be false, but we want loading to proceed */);
 
-	// UT_Byte is `unsigned char', so we need some nasty casts :-(
-	class UT_ByteBuf props(256);
-	const XML_Char* propsArray[11];
+	UT_UTF8String props;
+	const XML_Char* propsArray[13];
+	UT_Error res;
 
 	// Get all attributes into prop
-	if (!(getParagraphAttributes(layout,&props)))
-		return false;
+	if ((res = getParagraphAttributes(layout,props)))
+		return UT_IE_IMPORTERROR;
 
 	// HACK: Handle bullets
-	// This is really, really ugly. One day, when fields have stabilized,
-	// we will do it better.
+	// This is really, really ugly.
+	// We can not really select the bullet symbol to use, so we do not even
+	// try and just use always the plain round bullet.
+	// Indent magic is done in getParagraphAttributes.
 	if (layout->bullet->on) {
-		// Hardcode the stylename; it is the only way at this moment...
-		// This means that we throw away the real style if styles are enabled...
-		stylename = (const XML_Char *) "Bullet List";
+		props += ";list-style:Bullet List;field-font:Symbol";
 		// We need to generate the list once, but only if we actually
 		// have a bullet somewhere. Nasty. The attributes are mostly
 		// black magickish...
-		if (!listid) {
-			listid = (const XML_Char *) "666";
+		if (!list) {
+			list = true;
 			propsArray[0] = (const XML_Char *) "id";
-			propsArray[1] = listid;
+			propsArray[1] = global_listid;
 			propsArray[2] = (const XML_Char *) "parentid";
 			propsArray[3] = (const XML_Char *) "0";
 			propsArray[4] = (const XML_Char *) "type";
@@ -567,35 +708,36 @@
 			propsArray[7] = (const XML_Char *) "0";
 			propsArray[8] = (const XML_Char *) "list-delim";
 			propsArray[9] = (const XML_Char *) "%L";
-			propsArray[10] =(const XML_Char *)  NULL;
+			propsArray[10] = (const XML_Char *) "list-decimal";
+			propsArray[11] = (const XML_Char *) "NULL";
+			propsArray[12] =(const XML_Char *)  NULL;
 			getDoc()->appendList(propsArray);
 		}
 	}
 
-	// Append the string termination character '\000'
-	props.append((unsigned char *) "",1);
-
-	// UT_DEBUGMSG(("Paragraph: %s\n",props.getPointer(0)));
+	// Prepare the properties for this paragraph strux
+	UT_DEBUGMSG(("PSION: Paragraph: %s\n",props.utf8_str()));
 	propsArray[0] = (const XML_Char *) "props";
-	propsArray[1] = (const XML_Char *) props.getPointer(0);
+	propsArray[1] = (const XML_Char *) props.utf8_str();
 	propsArray[2] = (const XML_Char *) "style";
 	propsArray[3] = stylename;
 	propsArray[4] = (const XML_Char *) NULL;
 
+	// Bullets need the listid too.
 	if (layout->bullet->on) {
 		propsArray[4] = (const XML_Char *) "listid";
-		propsArray[5] = listid;
+		propsArray[5] = global_listid;
 		propsArray[6] = (const XML_Char *) NULL;
 	}
 
 	if (!(appendStrux(PTX_Block,propsArray)))
-		return false;
+		return UT_IE_IMPORTERROR;
 
-	// HACK: there is no real setting to do this.
+	// HACK: there is no real setting to do this. Yet.
 	if (layout->on_next_page) {
 		UT_UCSChar ucs = UCS_FF;
 		if (!(appendSpan(&ucs,1)))
-			return false;
+			return UT_IE_IMPORTERROR;
 	}
 
 	// We need to append a field and some other stuff...
@@ -604,57 +746,51 @@
 		propsArray[1] = (const XML_Char *) "list_label";
 		propsArray[2] = (const XML_Char *) NULL;
 		if (!(appendObject(PTO_Field,propsArray)))
-			return false;
+			return UT_IE_IMPORTERROR;
 
-		// If this is a bullet-with-indent, we need a tab to get the
-		// text alligned to the selected left margin.
-		if (layout->bullet->indent) {
+		// In some cases, but not in all, we need a tab after the bullet.
+		// See the Psiconv docs for the (ugly) details.
+		if ((!layout->bullet->indent && (layout->indent_first > 0)) || 
+			layout->bullet->indent) {
 			UT_UCSChar uc = (UT_UCSChar) UCS_TAB;
 			if (!(appendSpan(&uc,1)))
-				return false;
+				return UT_IE_IMPORTERROR;
 		}
 	}
-	return true;
+	return UT_OK;
 }
 
-// Get all character-related attributes and append them to props.
-// Note that you have to append a string termination character yourself!
-// props is allocated on the heap if it is NULL.
-// If props is not empty, we start with '; ', else we do not.
-bool IE_Imp_Psion::getCharacterAttributes(psiconv_character_layout layout,
-                                             UT_ByteBuf *props)
+/*!  
+ * Get all character-related attributes and append them to props.
+ *
+ * If props is not empty, we start with '; ', else we do not.
+ */
+UT_Error IE_Imp_Psion::getCharacterAttributes(const psiconv_character_layout layout,
+                                             UT_UTF8String &props)
 {
 	UT_return_val_if_fail(layout != NULL, true /* perhaps should be false, but we want loading to proceed */);
 
-	// This is only used for fixed string expansions, and should be big
-	// enough in all circumstances.
-	UT_String buffer;
+	UT_UTF8String buffer;
 	int fontsize;
+	UT_UCS4Char ucs4char;
+	int i;
 
-	bool props_allocated = false;
-
-	if (!props) {
-		props = new UT_ByteBuf(256);
-		props_allocated = true;
-	}
-
-	if (props->getLength())
-		if (!(props->append((unsigned char *) "; ",2)))
-			goto ERROR;
-
+	// Append a semicolon if there is already text in the props
+	if (props.length())
+		props += "; ";
+		
 	// font family
-	// BUG: No checking is done yet whether this family is known to AbiWord
-	// and no sanitizing of the font name is done. Theoretically, this
-	// could bomb Abiword if you hand-edited a Psion file and have the
-	// font-family name contain really weird stuff.
-	buffer = "font-family:";
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-	// We can't UT_String_sprintf this to buffer, because it might be long.
-	if (!(props->append((unsigned char *) layout->font->name,
-	                    strlen(layout->font->name))))
-		goto ERROR;
-
+	// BUG: No checking is done yet whether this family is known to AbiWord.
+	// We need to sanitize the font name first, or we could confuse the
+	// properties parser.
+	props += "font-family:";
+	for (i = 0; i < psiconv_unicode_strlen(layout->font->name); i++) {
+		ucs4char = layout->font->name[i];
+		if ((ucs4char < 0x20) || (ucs4char == ';') || (ucs4char == ':'))
+			ucs4char = '?';
+		props.appendUCS4(&ucs4char,1);
+	}
+	
 	// font size.
 	// This should be moved to some general-purpose function.
 	// At the moment, only the following font-sizes seem to be supported
@@ -675,357 +811,90 @@
 		else
 			fontsize = 72;
 	}
-	UT_String_sprintf(buffer,"; font-size:%dpt",fontsize);
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	UT_UTF8String_sprintf(buffer,"; font-size:%dpt",fontsize);
+	props += buffer;
+	
 	// bold
-	UT_String_sprintf(buffer, "; font-weight:%s", layout->bold ? "bold" : "normal");
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	UT_UTF8String_sprintf(buffer, "; font-weight:%s", layout->bold ? "bold" : "normal");
+	props += buffer;
+	
 	// italic
-	UT_String_sprintf(buffer, "; font-style:%s",layout->italic ? "italic" : "normal");
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
-	// underline & overline & strike-out
-	UT_String_sprintf(buffer, "; text-decoration:%s",
+	UT_UTF8String_sprintf(buffer, "; font-style:%s",layout->italic ? "italic" : "normal");
+	props += buffer;
+	
+	// underline and strike-through
+	UT_UTF8String_sprintf(buffer, "; text-decoration:%s",
 	        layout->underline && layout->strikethrough?"underline line-through":
 	        layout->underline && !layout->strikethrough?"underline":
 	        !layout->underline && layout->strikethrough?"line-through":
 		                                                "none");
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	props += buffer;
+	
 	// superscript and subscript
-	UT_String_sprintf(buffer, "; text-position:%s",
+	UT_UTF8String_sprintf(buffer, "; text-position:%s",
 	       layout->super_sub == psiconv_superscript?"superscript":
 	       layout->super_sub == psiconv_subscript  ?"subscript":
 		                                            "normal");
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
-	// color
-	UT_String_sprintf(buffer, "; color:%02x%02x%02x", (layout->color->red),
+	props += buffer;
+	
+	// text color
+	UT_UTF8String_sprintf(buffer, "; color:%02x%02x%02x", (layout->color->red),
 	                                        (layout->color->green),
 	                                        (layout->color->blue));
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
+	props += buffer;
+	
 	// background color
-	UT_String_sprintf(buffer, "; bgcolor:%02x%02x%02x", layout->back_color->red,
+	UT_UTF8String_sprintf(buffer, "; bgcolor:%02x%02x%02x", layout->back_color->red,
 	                                          layout->back_color->green,
 	                                          layout->back_color->blue);
-	if (!(props->append((unsigned char *) buffer.c_str(),buffer.size())))
-		goto ERROR;
-
-	return true;
-
-ERROR:
-	if (props_allocated)
-		delete props;
-	return  false;
+	props += buffer;
+	return UT_OK;
 }
 
 
-// Amazing. This actually works, even though it is stolen from the RTF importer
-// and mutilated severely by me.
-// It does an appendFmt setting the current character attributes. The next
-// appendSpan will use these settings.
-bool IE_Imp_Psion::applyCharacterAttributes(psiconv_character_layout layout)
+/*!  
+ * Get all character-related attributes and add them to the document.
+ *
+ * It does an appendFmt setting the current character attributes. The next
+ * appendSpan will use these settings.
+ */
+UT_Error IE_Imp_Psion::applyCharacterAttributes(const psiconv_character_layout layout)
 {
 	UT_return_val_if_fail(layout != NULL, true /* perhaps should be false, but we want loading to proceed */);
+	UT_Error res;
 
-	// UT_Byte is `unsigned char', so we need some nasty casts :-(
-	class UT_ByteBuf props(256);
+	class UT_UTF8String props;
 
 	// Get all attributes into prop
-	if (!(getCharacterAttributes(layout,&props)))
-		return false;
-
-	// Append the string termination character '\000'
-	props.append((unsigned char *) "",1);
+	if ((res = getCharacterAttributes(layout,props)))
+		return res;
 
-	// UT_DEBUGMSG(("Character: %s\n",props.getPointer(0)));
+	UT_DEBUGMSG(("PSION: Character: %s\n",props.utf8_str()));
 
+	// Propare the Fmt properties
 	const XML_Char* propsArray[3];
 	propsArray[0] = (const XML_Char *) "props";
-	propsArray[1] = (const XML_Char *) props.getPointer(0);
+	propsArray[1] = (const XML_Char *) props.utf8_str();
 	propsArray[2] = NULL;
 
-	return appendFmt(propsArray);
-}
-
-
-/* pBB is a PNG byte buffer, inserts picture in current spot */
-UT_Error  IE_Imp_Psion::insertGraphicFile(UT_ByteBuf* pBB, int width, int height)
-{
-    if (!pBB) return UT_ERROR;
-
-#if 0
-	if (!getDoc()->appendStrux(PTX_Section, NULL) ||
-	    !getDoc()->appendStrux(PTX_Block, NULL))
-     		return UT_IE_NOMEMORY;
-#endif
-   
-#if 0
-   	FG_Graphic* pFG;
-	FG_GraphicRaster *pFGR;
-
-	pFGR = new FG_GraphicRaster();
-	if(pFGR == NULL)
-		return UT_IE_NOMEMORY;
-
-	if(!pFGR->setRaster_PNG(pBB)) {
-		DELETEP(pFGR);
-		
-		return UT_IE_FAKETYPE;
-	}
-
-	pFG = static_cast<FG_Graphic *>(pFGR);
-   
-
-   	UT_ByteBuf * buf;
-    buf = (static_cast<FG_GraphicRaster*>(pFG))->getRaster_PNG();
-#endif
-   	const char * mimetype = NULL;
-    mimetype =UT_strdup("image/png");
-
-   	const XML_Char* propsArray[5];
-		UT_uint32 iid = getDoc()->getUID(UT_UniqueId::Image);
-		UT_String szName;
-		UT_String_sprintf(szName, "image_%d", iid);
-   	propsArray[0] = "dataid";
-   	propsArray[1] = szName.c_str(); //"image_0";
-	propsArray[2] = static_cast<const XML_Char *>("props");
-		UT_String szSize;
-		float fHeight = static_cast<float>(UT_convertDimToInches((double)height, DIM_PT));
-		float fWidth  = static_cast<float>(UT_convertDimToInches((double)width, DIM_PT));
-		UT_String_sprintf(szSize, "width:%fin; height:%fin", fWidth, fHeight);
-		UT_DEBUGMSG((szSize.c_str()));
-	propsArray[3] = szSize.c_str();
-   	propsArray[4] = NULL;
-   
-   	if (!getDoc()->appendObject(PTO_Image, propsArray)) {
-	   //delete pFG;
-	   FREEP(mimetype);
-	   return UT_IE_NOMEMORY;
-	}
-
-   	if (!getDoc()->createDataItem(szName.c_str()/*"image_0"*/, false,
-					pBB /*buf*/, static_cast<const void*>(mimetype), NULL)) {
-	   //delete pFG;
-	   // mimetype will be freed by crateDataItem
-	   //FREEP(mimetype);
-	   return UT_IE_NOMEMORY;
-	}
-
-   	//delete pFG;
-
+	if (!(appendFmt(propsArray)))
+		return UT_IE_IMPORTERROR;
 	return UT_OK;
 }
 
-static void _write_png( png_structp png_ptr, 
-		        png_bytep data, 
-		        png_size_t length )
-{
-	UT_ByteBuf* bb = static_cast<UT_ByteBuf*>(png_get_io_ptr(png_ptr));
-	bb->append(data, length);
-}
-
-static void _write_flush(png_structp png_ptr) { } // Empty Fuction.
-
-
-/* takes an [embedded] sketch image and converts to PNG byte data */
-UT_ByteBuf * IE_Imp_Psion::convertSketch2Png(psiconv_sketch_f sketchfile)
-{
-   psiconv_paint_data_section pic = sketchfile->sketch_sec->picture;
-
-   png_structp png_ptr;
-   png_infop info_ptr;
-   png_colorp palette;
-
-   /* Create and initialize the png_struct with the desired error handler
-    * functions.  If you want to use the default stderr and longjump method,
-    * you can supply NULL for the last three parameters.  We also check that
-    * the library version is compatible with the one used at compile time,
-    * in case we are using dynamically linked libraries.  REQUIRED.
-    */
-   png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,
-      NULL, NULL, NULL); //png_voidp user_error_ptr, user_error_fn, user_warning_fn
-
-   if (png_ptr == NULL)
-   {
-      return NULL;
-   }
-
-   /* Allocate/initialize the image information data.  REQUIRED */
-   info_ptr = png_create_info_struct(png_ptr);
-   if (info_ptr == NULL)
-   {
-      png_destroy_write_struct(&png_ptr,  png_infopp_NULL);
-      return NULL;
-   }
-
-   /* Set error handling.  REQUIRED if you aren't supplying your own
-    * error handling functions in the png_create_write_struct() call.
-    */
-   if (setjmp(png_jmpbuf(png_ptr)))
-   {
-      /* If we get here, we had a problem reading the file */
-      png_destroy_write_struct(&png_ptr, &info_ptr);
-      return NULL;
-   }
-
-   UT_ByteBuf *pBB = new UT_ByteBuf;  /* Byte Buffer for Converted Data */
-
-   /* Setting up the Data Writing Function */
-   png_set_write_fn(png_ptr, static_cast<void *>(pBB), 
-      static_cast<png_rw_ptr>(_write_png), static_cast<png_flush_ptr>(_write_flush));
-
-
-   png_uint_32 height=pic->ysize, width=pic->xsize, bitdepth=8;
-
-
-   /* Set the image information here.  Width and height are up to 2^31,
-    * bit_depth is one of 1, 2, 4, 8, or 16, but valid values also depend on
-    * the color_type selected. color_type is one of PNG_COLOR_TYPE_GRAY,
-    * PNG_COLOR_TYPE_GRAY_ALPHA, PNG_COLOR_TYPE_PALETTE, PNG_COLOR_TYPE_RGB,
-    * or PNG_COLOR_TYPE_RGB_ALPHA.  interlace is either PNG_INTERLACE_NONE or
-    * PNG_INTERLACE_ADAM7, and the compression_type and filter_type MUST
-    * currently be PNG_COMPRESSION_TYPE_BASE and PNG_FILTER_TYPE_BASE. REQUIRED
-    */
-   png_set_IHDR(png_ptr, info_ptr, width, height, bitdepth, PNG_COLOR_TYPE_RGB,
-      PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-
-   /* set the palette if there is one.  REQUIRED for indexed-color images */
-   palette = (png_colorp)png_malloc(png_ptr, PNG_MAX_PALETTE_LENGTH
-             * sizeof (png_color));
-   for (int i = (PNG_MAX_PALETTE_LENGTH)-1; i >= 0; i--)
-   {
-		palette[i].red = 0xAA;
-		palette[i].green = 0xAA;
-		palette[i].blue = 0xAA;
-   }
-   /* ... set palette colors ... */
-   png_set_PLTE(png_ptr, info_ptr, palette, PNG_MAX_PALETTE_LENGTH);
-   /* You must not free palette here, because png_set_PLTE only makes a link to
-      the palette that you malloced.  Wait until you are about to destroy
-      the png structure. */
-
-#if 0
-   /* optional significant bit chunk */
-   /* if we are dealing with a grayscale image then */
-   sig_bit.gray = true_bit_depth;
-   /* otherwise, if we are dealing with a color image then */
-   sig_bit.red = true_red_bit_depth;
-   sig_bit.green = true_green_bit_depth;
-   sig_bit.blue = true_blue_bit_depth;
-   /* if the image has an alpha channel then */
-   sig_bit.alpha = true_alpha_bit_depth;
-   png_set_sBIT(png_ptr, info_ptr, sig_bit);
-#endif
-
-
-   /* Write the file header information.  REQUIRED */
-   png_write_info(png_ptr, info_ptr);
-
-#if 0
-   /* set up the transformations you want.  Note that these are
-    * all optional.  Only call them if you want them.
-    */
-
-   /* invert monochrome pixels */
-   png_set_invert_mono(png_ptr);
-
-   /* Shift the pixels up to a legal bit depth and fill in
-    * as appropriate to correctly scale the image.
-    */
-   png_set_shift(png_ptr, &sig_bit);
-
-   /* pack pixels into bytes */
-   png_set_packing(png_ptr);
-#endif
-
-   UT_WARNINGMSG(("Image: width=%i, height=%i", width, height));
-   /* The easiest way to write the image (you may have a different memory
-    * layout, however, so choose what fits your needs best).  You need to
-    * use the first method if you aren't handling interlacing yourself.
-    */
-   png_uint_32 k;
-   png_bytep image = new png_byte[height*width*3]; //png_byte image[height][width*bytes_per_pixel];
-   png_bytep *row_pointers = new png_bytep[height];
-   for (k = 0; k < height; k++)
-   {
-     register png_uint_32 offset = k*width;
-     for (png_uint_32 j = 0; j < width; j++)
-     { /* Note that we must convert from 0.0-1.0 to 0-255 */
-       image[(offset+j)*3]   = static_cast<png_byte>(pic->red[offset+j]   * 255.0);
-       image[(offset+j)*3+1] = static_cast<png_byte>(pic->green[offset+j] * 255.0);
-       image[(offset+j)*3+2] = static_cast<png_byte>(pic->blue[offset+j]  * 255.0);
-     }
-     row_pointers[k] = image+offset*3; /*+ k*width*bytes_per_pixel*/
-   }
-
-   /* One of the following output methods is REQUIRED */
-   /* write out the entire image data in one call */
-   png_write_image(png_ptr, row_pointers);
-
-   /* It is REQUIRED to call this to finish writing the rest of the file */
-   png_write_end(png_ptr, info_ptr);
-
-   /* If you png_malloced a palette, free it here (don't free info_ptr->palette,
-      as recommended in versions 1.0.5m and earlier of this example; if
-      libpng mallocs info_ptr->palette, libpng will free it).  If you
-      allocated it with malloc() instead of png_malloc(), use free() instead
-      of png_free(). */
-   png_free(png_ptr, palette);
-   palette=NULL;
-
-   /* clean up after the write, and free any memory allocated */
-   png_destroy_write_struct(&png_ptr, &info_ptr);
-
-   /* that's it */
-	insertGraphicFile(pBB, width, height);
-	return pBB;
-}
-
-
-// append a string (assumes ASCII 7bit C-String) to block
-static bool appendCStr(const char *input, UT_GrowBuf *gbBlock)
-{
-	register UT_UCS4Char uc;
-	register const char *p = input;
-
-	while(p && *p)
-	{
-		uc = (UT_UCS4Char)*p;
-		if (!(gbBlock->append((const UT_GrowBufElement *)&uc,1)))
-			return false;
-		p++;
-	}
-
-	return true;
-}
 
-// Read length character from input, translate them to the internal
-// Abiword format, and append them to the gbBlock.
-// You must insure the input has at least length characters!
-bool IE_Imp_Psion::prepareCharacters(char *input, int length,
-                                        UT_GrowBuf *gbBlock,
-                                        psiconv_list embobjlst)
+/* Read characters from input and append them to text
+ * 
+ * You must insure the input has at least length characters!
+ * We handle special Psion markup tokens here. Except object markers,
+ * they are handled in readParagraphs.
+ */
+UT_Error IE_Imp_Psion::prepareCharacters(const psiconv_ucs2 *input, int length,
+                                        UT_UCS4String &text)
+//                                        psiconv_list embobjlst)
 {
-	class UT_UCS4_mbtowc mbtowc;
-	UT_UCS4Char uc;
-	UT_UCS4Char wc;
 	int i;
-    psiconv_file embfile;
-
-	const char *szEncoding = XAP_EncodingManager::get_instance()->
-                                                     charsetFromCodepage(1252);
-
-	mbtowc.setInCharset(szEncoding);
+	UT_UCS4Char uc;
 
 	for (i = 0; i < length; i++) {
 		// Note that we may actually encounter an '\000' here too. This
@@ -1048,183 +917,317 @@
 			continue;
 		else if (input[i] == '\015') // Unknown functionality
 			continue;
-		else if (input[i] == '\016') // Object placeholder
-		{
-		                             // Not yet implemented in psiconv TODO
-			if (psiconv_list_is_empty(embobjlst))
-				appendCStr("<embedded object missing>", gbBlock);
-			else
-			{
-				embfile = static_cast<psiconv_file>(psiconv_list_get(embobjlst,embobjN));
-				switch(embfile->type)
-				{
-					case psiconv_sketch_file:
-					{
-						//appendCStr("<sketch object>", gbBlock);
-						//insertGraphicFile(convertSketch2Png(static_cast<psiconv_sketch_f>(embfile->file)));
-						UT_ByteBuf *pBB = convertSketch2Png(static_cast<psiconv_sketch_f>(embfile->file));
-						DELETEP(pBB);
-					break;
-					}
-					case psiconv_sheet_file:
-						appendCStr("<sheet object>", gbBlock);
-					break;
-					case psiconv_word_file:
-						appendCStr("<word object>", gbBlock);
-					break;
-					case psiconv_texted_file:
-						appendCStr("<texted object>", gbBlock);
-					break;
-					case psiconv_mbm_file:
-						appendCStr("<mbm object>", gbBlock);
-					break;
-					case psiconv_clipart_file:
-						appendCStr("<clipart object>", gbBlock);
-					break;
-					// psiconv_unknown_file:
-					default:
-						appendCStr("<unknown embedded object>", gbBlock);
-				}
-				embobjN++;  // point to next embedded object
-			}
-			continue;
-		}
 		else if (input[i] == '\017') // Visible space. Handle as normal space.
 			uc = UCS_SPACE;
-		else if (input[i] == '\020') // Unbreakable space
-			uc = UCS_NBSP;
-		else if ((input [i] >= 0) && (input[i] < 32)) // Not implemented
+		else if (input[i] < 32) // Not implemented
 			continue;
-		else if (!mbtowc.mbtowc(wc,input[i]))
-			continue;
-		else
-			 uc = (UT_UCS4Char) wc;
-		if (!(gbBlock->append((const UT_GrowBufElement *)&uc,1)))
-			return false;
+		else // More or less normal character
+			uc = input[i];
+		text += uc;
 	}
-	return true;
+	return UT_OK;
+}
+
+/*!
+ * Insert an image in the current document.
+ *
+ * The image is found in an in_line Psiconv element.
+ */
+UT_Error IE_Imp_Psion::insertImage(const psiconv_in_line_layout in_line)
+{
+	psiconv_sketch_f sketch_file;
+	psiconv_paint_data_section paint_data;
+	UT_ByteBuf image_buffer;
+	png_byte *row;
+	UT_UTF8String props,iname,buffer;
+	const XML_Char* propsArray[13];
+	int x,y,xsize,ysize;
+	char *mimetype;
+	UT_uint32 iid;
+	
+	// Get the sketch file
+	sketch_file = (psiconv_sketch_f) (in_line->object->object->file);
+	paint_data = sketch_file->sketch_sec->picture;
+	xsize = paint_data->xsize;
+	ysize = paint_data->ysize;
+	UT_DEBUGMSG(("PSION: Picture %d x %d\n",xsize,ysize));
+	
+	// Prepare the PNG structure for writing
+	png_structp png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING, 
+	                                               NULL, NULL, NULL);
+    if (!png_ptr)
+       return UT_IE_IMPORTERROR;
+
+	// Prepare the PNG structure for info
+    png_infop info_ptr = png_create_info_struct(png_ptr);
+    if (!info_ptr)
+    {
+       png_destroy_write_struct(&png_ptr,NULL);
+       return UT_IE_IMPORTERROR;
+    }	
+
+	// Prepare PNG error handling
+	if (setjmp(png_jmpbuf(png_ptr)))
+    {
+		UT_DEBUGMSG(("PSION: PNG Error handler"));
+     	png_destroy_write_struct(&png_ptr, &info_ptr);
+     	return (UT_IE_IMPORTERROR);
+    }
+	
+	// Use our own functions for writing the PNG data stream
+	png_set_write_fn(png_ptr,(void *) &image_buffer,write_png_data,
+	                 write_png_flush);
+	
+	// Set picture data
+	png_set_IHDR(png_ptr,info_ptr,xsize,
+	             ysize,8,PNG_COLOR_TYPE_RGB,
+	             PNG_INTERLACE_NONE,PNG_COMPRESSION_TYPE_DEFAULT,
+	             PNG_FILTER_TYPE_DEFAULT);
+	png_set_oFFs(png_ptr,info_ptr,
+	             sketch_file->sketch_sec->picture_data_x_offset,
+	             sketch_file->sketch_sec->picture_data_y_offset,
+	             PNG_OFFSET_PIXEL);
+	// Not yet implemented: magnification, cuts
+	
+	// Allocate one row of pixels
+	if (!(row = (png_byte *) malloc(sizeof(png_byte) * xsize * 3))) {
+		png_destroy_write_struct(&png_ptr,&info_ptr);
+		return UT_IE_IMPORTERROR;
+	}		
+		
+	// Writing the PNG file
+	png_write_info(png_ptr,info_ptr);
+	for (y = 0; y < ysize; y++) {
+		for (x = 0; x < xsize; x++) {
+			row[3*x] = (png_byte) (paint_data->red[y * xsize + x] * 255.0);
+			row[3*x+1] = (png_byte) (paint_data->green[y * xsize + x] * 255.0);
+			row[3*x+2] = (png_byte) (paint_data->blue[y * xsize + x] * 255.0);
+			UT_DEBUGMSG(("PSION: Pixels %d %d %d\n",row[3*x],row[3*x+1],row[3*x+2]));
+		}
+		UT_DEBUGMSG(("PSION: Row %d\n",y));
+		png_write_row(png_ptr,row);
+	}
+	png_write_end(png_ptr,info_ptr);
+	free(row);
+	png_destroy_write_struct(&png_ptr,&info_ptr);
+
+	// Width
+	UT_UTF8String_sprintf(buffer,"width:%dpt",xsize);
+	props += buffer;
+	
+	// Height
+	UT_UTF8String_sprintf(buffer,"; height:%dpt",ysize);
+	props += buffer;
+	
+	// Unique ID
+	iid = getDoc()->getUID(UT_UniqueId::Image);
+	UT_UTF8String_sprintf(iname,"image_%d",iid);
+	
+	// Set the properties
+	// Note that we both have to add a Data Item (containing the image) and 
+	// the object (just a reference to the Data Item).
+	propsArray[0] = (const XML_Char *) "dataid";
+	propsArray[1] = (const XML_Char *) (iname.utf8_str());
+	propsArray[2] = (const XML_Char *) "props";
+	propsArray[3] = (const XML_Char *) (props.utf8_str());
+	propsArray[4] = NULL;
+	if (!(getDoc()->appendObject(PTO_Image,propsArray)))
+		return UT_IE_IMPORTERROR;
+	if (!(mimetype = UT_strdup("image/png")))
+		return UT_IE_NOMEMORY;
+	if (!(getDoc()->createDataItem(iname.utf8_str(),false,&image_buffer,
+		 (const void*) mimetype,NULL)))
+		return UT_IE_IMPORTERROR;
+	return UT_OK;
 }
 
-UT_Error IE_Imp_Psion::readParagraphs(psiconv_text_and_layout psiontext,
-                                      psiconv_word_styles_section style_sec,
-                                      psiconv_list embobjlst)
+/*! 
+ * Insert an object.
+ *
+ * At the moment, we only handle images. All other objects are ignored.
+ */
+UT_Error IE_Imp_Psion::insertObject(const psiconv_in_line_layout in_line)
+{
+	// Not yet implemented: object_display_section, object_icon_section,
+	// Not yet implemented: object width and height
+	
+	// We only accept Sketch objects (pictures) for now.
+	if (!in_line || !in_line->object || !in_line->object->object ||
+		(in_line->object->object->type != psiconv_sketch_file)) {
+		UT_DEBUGMSG(("PSION: Unsupported object (ignored)\n"));
+		return UT_OK;
+	}
+	return insertImage(in_line);
+}
+
+/*!
+ * Read all Psion paragraphs and add them to the document.
+ */
+UT_Error IE_Imp_Psion::readParagraphs(const psiconv_text_and_layout psiontext,
+                                      const psiconv_word_styles_section style_sec)
+//                                      psiconv_list embobjlst)
 {
 	unsigned int i,inline_nr,loc;
 	psiconv_paragraph paragraph;
 	psiconv_in_line_layout in_line;
-	UT_GrowBuf gbBlock;
+	UT_UCS4String text;
 	psiconv_word_style style;
 	const XML_Char *stylename;
+	UT_Error res;
 
+	// Iterate through all paragraphs
 	for (i=0; i < psiconv_list_length(psiontext); i++) {
+
+		UT_DEBUGMSG(("PSION: Importing paragraph %d\n",i));
 		if (!(paragraph = (psiconv_paragraph) psiconv_list_get(psiontext,i))) {
 			// Something is really wrong...
 			UT_ASSERT(paragraph != NULL);
-			return UT_ERROR;
+			return UT_IE_IMPORTERROR;
 		}
-
-		// Determine the style name
+	
+		// Determine the style name; set it to Normal if it is not available
 		if (!style_sec ||
-		      !(style = psiconv_get_style(style_sec,paragraph->base_style)) ||
-		  	  !(stylename = style->name))
-			stylename = (const XML_Char *) "Normal";
-
-		loc = 0;
-		if (!(applyParagraphAttributes(paragraph->base_paragraph,stylename)))
+		    !(style = psiconv_get_style(style_sec,paragraph->base_style)) ||
+			(!style->name) || 
+		  	!(stylename = prepare_style_name(style->name)))
+			stylename = (const XML_Char *) strdup("Normal");
+		if (!stylename)
 			return UT_IE_NOMEMORY;
+		UT_DEBUGMSG(("PSION: paragraph %d: style %s\n",i,stylename));
+		
+		// Add all paragraph attributes to the document
+		if ((res = applyParagraphAttributes(paragraph->base_paragraph,stylename)))
+			return res;
+		
+		// Iterate through all Psion inlines. These contain the character
+		// layout information, together with the number of characters they
+		// apply to.
+		loc = 0;
 		for(inline_nr=0; inline_nr < psiconv_list_length(paragraph->in_lines);
 		    inline_nr++) {
 			if (!(in_line = (psiconv_in_line_layout) psiconv_list_get(paragraph->in_lines,inline_nr))) {
 				// Something is really wrong...
 				UT_ASSERT(in_line != NULL);
-				return UT_ERROR;
+				return UT_IE_IMPORTERROR;
 			}
-			gbBlock.truncate(0);
-			if (!(prepareCharacters(paragraph->text + loc,in_line->length,
-			      &gbBlock, embobjlst)))
-				return UT_IE_NOMEMORY;
-			// Yes, gbBlock may be empty!
-			if (gbBlock.getLength()) {
-				if (!( applyCharacterAttributes(in_line->layout)))
-					return UT_IE_NOMEMORY;
-				if (!( appendSpan((const UT_UCSChar*)gbBlock.getPointer(0),
-		   		                  gbBlock.getLength())))
-					return UT_IE_NOMEMORY;
+			// This may be an object, which needs special handling.
+		 	// Objects have layout associated with them, but we will ignore
+			// it. I am not sure how it would apply anyway. We will also ignore
+			// all text. It should just be a single character \016, which is the
+			// object marker.
+			if (in_line->object) 
+				if ((res = insertObject(in_line)))
+					return res;
+			else {		
+				// Put all characters belonging to the current inline into text
+				text.clear();
+				if ((res = prepareCharacters(paragraph->text + loc,in_line->length,
+					  text)))
+					return res;
+				// Yes, text may be empty!
+				if (text.length()) {
+					// Add the character layout and the text itself to the document
+					if ((res = applyCharacterAttributes(in_line->layout)))
+						return res;
+					if (!(appendSpan((text.ucs4_str()),text.length())))
+						return UT_IE_IMPORTERROR;
+				}
 			}
 			loc += in_line->length;
 		}
-		if (loc < strlen(paragraph->text)) {
-			gbBlock.truncate(0);
-			if (!(prepareCharacters(paragraph->text+loc,
-			                       strlen(paragraph->text - loc),&gbBlock,embobjlst)))
-				return UT_IE_NOMEMORY;
-			// Yes, gbBlock may be empty!
-			if (gbBlock.getLength()) {
-				if (!(applyCharacterAttributes(paragraph->base_character)))
-					return UT_IE_NOMEMORY;
-				if (!( appendSpan((const UT_UCSChar*)gbBlock.getPointer(0),
-		   		                  gbBlock.getLength())))
-					return UT_IE_NOMEMORY;
+
+		// There may be text left after iterating through all inlines.
+		// This remaining text gets the paragraph base_character layout.
+		if (loc < psiconv_unicode_strlen(paragraph->text)) {
+			// Get the remaining characters into text
+			text.clear();
+			if ((res = prepareCharacters(paragraph->text+loc,
+			                       psiconv_unicode_strlen(paragraph->text - loc),text)))
+				return res;
+
+			// Yes, text may be empty!
+			if (text.length()) {
+				// Add the character layout and the text itself to the document.
+
+				if ((res = applyCharacterAttributes(paragraph->base_character)))
+					return res;
+
+				if (!appendSpan(text.ucs4_str(),text.length()))
+					return UT_IE_IMPORTERROR;
 			}
 		}
 	}
 	return UT_OK;
 }
 
-/*****************************************************************/
-/*****************************************************************/
+/***************************
+ * class IE_Imp_Psion_Word *
+ ***************************/
 
-IE_Imp_Psion_Word::~IE_Imp_Psion_Word()
-{
-}
-
-IE_Imp_Psion_Word::IE_Imp_Psion_Word(PD_Document * pDocument)
-	: IE_Imp_Psion(pDocument)
-{
-}
-
-UT_Error IE_Imp_Psion_Word::parseFile(psiconv_file psionfile)
+/*!  
+ * Translate a psiconv Word file representation into an AbiWord document
+ */
+UT_Error IE_Imp_Psion_Word::parseFile(const psiconv_file psionfile)
 {
-	embobjN = 0;	// reset embedded object index
+	UT_Error res;
+	bool header,footer;
+	UT_DEBUGMSG(("PSION: Parsing Psion Word file\n"));
 
+	// It really should be a Word file!
 	if (psionfile->type != psiconv_word_file)
 		return UT_IE_BOGUSDOCUMENT;
-
-	if (!applyStyles(((psiconv_word_f) (psionfile->file))->styles_sec))
-		return UT_IE_NOMEMORY;
-	if (!applyPageAttributes(((psiconv_word_f) (psionfile->file))->page_sec))
-		return UT_IE_NOMEMORY;
-	return readParagraphs(((psiconv_word_f) (psionfile->file))->paragraphs,
-	                      ((psiconv_word_f) (psionfile->file))->styles_sec,
-	                      psionfile->embobjlst);
+	psiconv_word_f file = (psiconv_word_f) (psionfile->file);
+	
+	// Handle all styles
+	if ((res = applyStyles(file->styles_sec)))
+		return res;
+
+	// Handle the page settings (they always apply to the whole document
+	if ((res = applyPageAttributes(file->page_sec,header,footer)))
+		return res;
+
+	// Handle all paragraphs with text and layout
+	if ((res = readParagraphs(file->paragraphs,file->styles_sec)))
+		return res;
+	
+	// Handle the headers and footers
+	if ((res = processHeaderFooter(file->page_sec,header,footer)))
+		return res;
+	
+	return UT_OK;
 }
 
-/*****************************************************************/
-/*****************************************************************/
 
-IE_Imp_Psion_TextEd::~IE_Imp_Psion_TextEd()
-{
-}
+/*****************************
+ * class IE_Imp_Psion_TextEd *
+ *****************************/
 
-IE_Imp_Psion_TextEd::IE_Imp_Psion_TextEd(PD_Document * pDocument)
-	: IE_Imp_Psion(pDocument)
-{
-}
-
-UT_Error IE_Imp_Psion_TextEd::parseFile(psiconv_file psionfile)
+/*!  
+ * Translate a psiconv TextEd file representation into an AbiWord document
+ */
+UT_Error IE_Imp_Psion_TextEd::parseFile(const psiconv_file psionfile)
 {
-	embobjN = 0;
-
+	UT_Error res;
+	bool header,footer;
+	
+	UT_DEBUGMSG(("PSION: Parsing Psion Texted file\n"));
+	// It really should be a TextEd file!
 	if (psionfile->type != psiconv_texted_file)
 		return UT_IE_BOGUSDOCUMENT;
+	psiconv_texted_f file = (psiconv_texted_f) (psionfile->file);
 
-	if (!applyPageAttributes(((psiconv_texted_f) (psionfile->file))->page_sec))
-		return UT_IE_NOMEMORY;
-	return readParagraphs(((psiconv_texted_f)
-	                       (psionfile->file))->texted_sec->paragraphs, NULL,
-	                       psionfile->embobjlst);
+	// Note that a TextEd document has no styles
+	
+	// Handle the page settings (they always apply to the whole document
+	if ((res = applyPageAttributes(file->page_sec,header,footer)))
+		return res;
+	// Handle all paragraphs with text and layout
+	if ((res = readParagraphs(file->texted_sec->paragraphs, NULL)))
+		return res;
+	
+	// Handle the headers and footers
+	if ((res = processHeaderFooter(file->page_sec,header,footer)))
+		return res;
+	
+	return UT_OK;
 }
-
-/*****************************************************************/
-/*****************************************************************/
-
diff -urN aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_imp_Psion.h abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_imp_Psion.h
--- aa/abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_imp_Psion.h	2003-10-05 23:43:16.000000000 +0200
+++ abiword-2.1.0/abiword-plugins/wp/impexp/psion/xp/ie_imp_Psion.h	2004-03-17 16:20:21.488932144 +0100
@@ -1,6 +1,6 @@
 /* AbiWord
  * Copyright (C) 2000 AbiSource, Inc.
- * Copyright (C) 2000 Frodo Looijaard <frodol@dds.nl>
+ * Copyright (C) 2000,2004 Frodo Looijaard <frodol@dds.nl>
  * 
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -25,105 +25,111 @@
 
 #include <stdio.h>
 #include "ie_imp.h"
-#include "ut_bytebuf.h"
-#include "ut_growbuf.h"
+#include "ie_impexp_Psion.h"
 
 #include <psiconv/data.h>
 
 class PD_Document;
 
-// The importer/reader for Psion Word Files.
+// The importer/reader for Psion Word and TextEd Files.
 
-class ABI_PLUGIN_EXPORT IE_Imp_Psion : public IE_Imp
+
+class ABI_PLUGIN_EXPORT IE_Imp_Psion_Sniffer : public IE_ImpSniffer
 {
 public:
-	IE_Imp_Psion(PD_Document * pDocument);
-	~IE_Imp_Psion();
-
-	virtual UT_Error	importFile(const char * szFilename);
-
+	IE_Imp_Psion_Sniffer(const char * name): IE_ImpSniffer(name) {}
+	virtual ~IE_Imp_Psion_Sniffer() {}
 protected:
-		bool			getCharacterAttributes(psiconv_character_layout layout, UT_ByteBuf *props);
-		bool			getParagraphAttributes(psiconv_paragraph_layout layout, UT_ByteBuf *props);
-		bool			applyCharacterAttributes(psiconv_character_layout layout);
-		bool			applyParagraphAttributes(psiconv_paragraph_layout layout,const char *stylename);
-		bool			applyPageAttributes(psiconv_page_layout_section layout);
-		bool			prepareCharacters(char *input, int length, 
-							  UT_GrowBuf *gbBlock, psiconv_list embobjlst);
-		UT_Error		readParagraphs(psiconv_text_and_layout psiontext, psiconv_word_styles_section style_sec, psiconv_list embobjlst);
-		bool			applyStyles(psiconv_word_styles_section style_sec);
-		UT_Error		insertGraphicFile(UT_ByteBuf* pBB, int width, int height);
-		UT_ByteBuf *	convertSketch2Png(psiconv_sketch_f sketchfile);
-
-
-		virtual	UT_Error	parseFile(psiconv_file psionfile) = 0;
-
-		psiconv_u32		embobjN;  // which embedded object next placement char represents
-
- private:
-	const char *listid;
+	UT_Confidence_t checkContents (const char *szBuf, UT_uint32 iNumbytes,
+	                               psiconv_file_type_t filetype);
 };
 
-
-class ABI_PLUGIN_EXPORT IE_Imp_Psion_Word_Sniffer : public IE_ImpSniffer
+class ABI_PLUGIN_EXPORT IE_Imp_Psion_Word_Sniffer : public IE_Imp_Psion_Sniffer
 {
-	friend class IE_Imp;
-
 public:
-	IE_Imp_Psion_Word_Sniffer(const char * name);
+	IE_Imp_Psion_Word_Sniffer(const char * name): IE_Imp_Psion_Sniffer(name) {}
 	virtual ~IE_Imp_Psion_Word_Sniffer() {}
 
 	virtual UT_Confidence_t recognizeContents (const char * szBuf, 
-									UT_uint32 iNumbytes);
+									           UT_uint32 iNumbytes);
 	virtual UT_Confidence_t recognizeSuffix (const char * szSuffix);
 	virtual bool getDlgLabels (const char ** szDesc,
 							   const char ** szSuffixList,
 							   IEFileType * ft);
 	virtual UT_Error constructImporter (PD_Document * pDocument,
 										IE_Imp ** ppie);
-
 };
 
-class ABI_PLUGIN_EXPORT IE_Imp_Psion_TextEd_Sniffer : public IE_ImpSniffer
+class ABI_PLUGIN_EXPORT IE_Imp_Psion_TextEd_Sniffer : 
+	                                                public IE_Imp_Psion_Sniffer
 {
-	friend class IE_Imp;
-
 public:
-	IE_Imp_Psion_TextEd_Sniffer(const char * name);
+	IE_Imp_Psion_TextEd_Sniffer(const char * name): 
+                                                  IE_Imp_Psion_Sniffer(name) {}
 	virtual ~IE_Imp_Psion_TextEd_Sniffer() {}
 
 	virtual UT_Confidence_t recognizeContents (const char * szBuf, 
-									UT_uint32 iNumbytes);
+									           UT_uint32 iNumbytes);
 	virtual UT_Confidence_t recognizeSuffix (const char * szSuffix);
 	virtual bool getDlgLabels (const char ** szDesc,
 							   const char ** szSuffixList,
 							   IEFileType * ft);
 	virtual UT_Error constructImporter (PD_Document * pDocument,
 										IE_Imp ** ppie);
-
 };
 
-class ABI_PLUGIN_EXPORT IE_Imp_Psion_Word : public IE_Imp_Psion
+class ABI_PLUGIN_EXPORT IE_Imp_Psion : public IE_Imp
 {
 public:
-	IE_Imp_Psion_Word(PD_Document * pDocument);
-	~IE_Imp_Psion_Word();
+	IE_Imp_Psion(PD_Document * pDocument): IE_Imp(pDocument),list(false) {}
+	~IE_Imp_Psion() {}
 
+	virtual UT_Error importFile(const char * szFilename);
 
 protected:
-	virtual	UT_Error	parseFile(psiconv_file psionfile);
+	UT_Error getCharacterAttributes(const psiconv_character_layout layout, 
+                                UT_UTF8String &props);
+	UT_Error getParagraphAttributes(const psiconv_paragraph_layout layout, 
+                                UT_UTF8String &props);
+	UT_Error applyCharacterAttributes(const psiconv_character_layout layout);
+	UT_Error applyParagraphAttributes(const psiconv_paragraph_layout layout,
+                                  const XML_Char *stylename);
+	UT_Error applyPageAttributes(const psiconv_page_layout_section layout,
+                                 bool &with_header, bool &with_footer);
+	UT_Error prepareCharacters(const psiconv_ucs2 *input, int length,
+                           UT_UCS4String &text);
+	UT_Error readParagraphs(const psiconv_text_and_layout psiontext,
+                            const psiconv_word_styles_section style_sec);
+	UT_Error applyStyles(const psiconv_word_styles_section style_sec);
+	UT_Error processHeaderFooter(const psiconv_page_layout_section layout,
+                                           bool with_header, bool with_footer);
+    UT_Error insertImage(const psiconv_in_line_layout in_line);
+	UT_Error insertObject(const psiconv_in_line_layout in_line);
+
+	virtual	UT_Error parseFile(const psiconv_file psionfile) = 0;
+
+ private:
+	bool list;
 };
 
-class ABI_PLUGIN_EXPORT IE_Imp_Psion_TextEd : public IE_Imp_Psion
+class ABI_PLUGIN_EXPORT IE_Imp_Psion_Word : public IE_Imp_Psion
 {
 public:
-	IE_Imp_Psion_TextEd(PD_Document * pDocument);
-	~IE_Imp_Psion_TextEd();
+	IE_Imp_Psion_Word(PD_Document * pDocument): IE_Imp_Psion(pDocument) {}
+	~IE_Imp_Psion_Word() {}
 
 protected:
-	virtual	UT_Error	parseFile(psiconv_file psionfile);
+	virtual	UT_Error parseFile(const psiconv_file psionfile);
 };
 
+class ABI_PLUGIN_EXPORT IE_Imp_Psion_TextEd : public IE_Imp_Psion
+{
+public:
+	IE_Imp_Psion_TextEd(PD_Document * pDocument): IE_Imp_Psion(pDocument) {}
+	~IE_Imp_Psion_TextEd() {}
 
+protected:
+	virtual	UT_Error parseFile(const psiconv_file psionfile);
+};
 
 #endif /* IE_IMP_PSION_H */
